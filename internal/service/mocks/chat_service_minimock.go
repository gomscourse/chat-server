// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/gomscourse/chat-server/internal/service.ChatService -o chat_service_minimock.go -n ChatServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	serviceModel "github.com/gomscourse/chat-server/internal/model"
	mm_service "github.com/gomscourse/chat-server/internal/service"
)

// ChatServiceMock implements service.ChatService
type ChatServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckChatAvailability          func(ctx context.Context, chatID int64, username string) (err error)
	inspectFuncCheckChatAvailability   func(ctx context.Context, chatID int64, username string)
	afterCheckChatAvailabilityCounter  uint64
	beforeCheckChatAvailabilityCounter uint64
	CheckChatAvailabilityMock          mChatServiceMockCheckChatAvailability

	funcCheckCtxUserChatAvailability          func(ctx context.Context, chatID int64) (err error)
	inspectFuncCheckCtxUserChatAvailability   func(ctx context.Context, chatID int64)
	afterCheckCtxUserChatAvailabilityCounter  uint64
	beforeCheckCtxUserChatAvailabilityCounter uint64
	CheckCtxUserChatAvailabilityMock          mChatServiceMockCheckCtxUserChatAvailability

	funcConnectChat          func(stream mm_service.Stream, chatID int64) (err error)
	inspectFuncConnectChat   func(stream mm_service.Stream, chatID int64)
	afterConnectChatCounter  uint64
	beforeConnectChatCounter uint64
	ConnectChatMock          mChatServiceMockConnectChat

	funcCreateChat          func(ctx context.Context, usernames []string, title string) (i1 int64, err error)
	inspectFuncCreateChat   func(ctx context.Context, usernames []string, title string)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatServiceMockCreateChat

	funcDeleteChat          func(ctx context.Context, chatID int64) (err error)
	inspectFuncDeleteChat   func(ctx context.Context, chatID int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatServiceMockDeleteChat

	funcGetAvailableChatsAndCount          func(ctx context.Context, page int64, pageSize int64) (cpa1 []*serviceModel.Chat, u1 uint64, err error)
	inspectFuncGetAvailableChatsAndCount   func(ctx context.Context, page int64, pageSize int64)
	afterGetAvailableChatsAndCountCounter  uint64
	beforeGetAvailableChatsAndCountCounter uint64
	GetAvailableChatsAndCountMock          mChatServiceMockGetAvailableChatsAndCount

	funcGetChannels          func() (m1 map[int64]chan *serviceModel.ChatMessage)
	inspectFuncGetChannels   func()
	afterGetChannelsCounter  uint64
	beforeGetChannelsCounter uint64
	GetChannelsMock          mChatServiceMockGetChannels

	funcGetChatMessagesAndCount          func(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, u1 uint64, err error)
	inspectFuncGetChatMessagesAndCount   func(ctx context.Context, chatID int64, page int64, pageSize int64)
	afterGetChatMessagesAndCountCounter  uint64
	beforeGetChatMessagesAndCountCounter uint64
	GetChatMessagesAndCountMock          mChatServiceMockGetChatMessagesAndCount

	funcInitMessagesChan          func(chatID int64) (ch1 chan *serviceModel.ChatMessage)
	inspectFuncInitMessagesChan   func(chatID int64)
	afterInitMessagesChanCounter  uint64
	beforeInitMessagesChanCounter uint64
	InitMessagesChanMock          mChatServiceMockInitMessagesChan

	funcSendMessage          func(ctx context.Context, text string, chatID int64) (err error)
	inspectFuncSendMessage   func(ctx context.Context, text string, chatID int64)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServiceMockSendMessage
}

// NewChatServiceMock returns a mock for service.ChatService
func NewChatServiceMock(t minimock.Tester) *ChatServiceMock {
	m := &ChatServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckChatAvailabilityMock = mChatServiceMockCheckChatAvailability{mock: m}
	m.CheckChatAvailabilityMock.callArgs = []*ChatServiceMockCheckChatAvailabilityParams{}

	m.CheckCtxUserChatAvailabilityMock = mChatServiceMockCheckCtxUserChatAvailability{mock: m}
	m.CheckCtxUserChatAvailabilityMock.callArgs = []*ChatServiceMockCheckCtxUserChatAvailabilityParams{}

	m.ConnectChatMock = mChatServiceMockConnectChat{mock: m}
	m.ConnectChatMock.callArgs = []*ChatServiceMockConnectChatParams{}

	m.CreateChatMock = mChatServiceMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatServiceMockCreateChatParams{}

	m.DeleteChatMock = mChatServiceMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatServiceMockDeleteChatParams{}

	m.GetAvailableChatsAndCountMock = mChatServiceMockGetAvailableChatsAndCount{mock: m}
	m.GetAvailableChatsAndCountMock.callArgs = []*ChatServiceMockGetAvailableChatsAndCountParams{}

	m.GetChannelsMock = mChatServiceMockGetChannels{mock: m}

	m.GetChatMessagesAndCountMock = mChatServiceMockGetChatMessagesAndCount{mock: m}
	m.GetChatMessagesAndCountMock.callArgs = []*ChatServiceMockGetChatMessagesAndCountParams{}

	m.InitMessagesChanMock = mChatServiceMockInitMessagesChan{mock: m}
	m.InitMessagesChanMock.callArgs = []*ChatServiceMockInitMessagesChanParams{}

	m.SendMessageMock = mChatServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceMockCheckChatAvailability struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCheckChatAvailabilityExpectation
	expectations       []*ChatServiceMockCheckChatAvailabilityExpectation

	callArgs []*ChatServiceMockCheckChatAvailabilityParams
	mutex    sync.RWMutex
}

// ChatServiceMockCheckChatAvailabilityExpectation specifies expectation struct of the ChatService.CheckChatAvailability
type ChatServiceMockCheckChatAvailabilityExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockCheckChatAvailabilityParams
	results *ChatServiceMockCheckChatAvailabilityResults
	Counter uint64
}

// ChatServiceMockCheckChatAvailabilityParams contains parameters of the ChatService.CheckChatAvailability
type ChatServiceMockCheckChatAvailabilityParams struct {
	ctx      context.Context
	chatID   int64
	username string
}

// ChatServiceMockCheckChatAvailabilityResults contains results of the ChatService.CheckChatAvailability
type ChatServiceMockCheckChatAvailabilityResults struct {
	err error
}

// Expect sets up expected params for ChatService.CheckChatAvailability
func (mmCheckChatAvailability *mChatServiceMockCheckChatAvailability) Expect(ctx context.Context, chatID int64, username string) *mChatServiceMockCheckChatAvailability {
	if mmCheckChatAvailability.mock.funcCheckChatAvailability != nil {
		mmCheckChatAvailability.mock.t.Fatalf("ChatServiceMock.CheckChatAvailability mock is already set by Set")
	}

	if mmCheckChatAvailability.defaultExpectation == nil {
		mmCheckChatAvailability.defaultExpectation = &ChatServiceMockCheckChatAvailabilityExpectation{}
	}

	mmCheckChatAvailability.defaultExpectation.params = &ChatServiceMockCheckChatAvailabilityParams{ctx, chatID, username}
	for _, e := range mmCheckChatAvailability.expectations {
		if minimock.Equal(e.params, mmCheckChatAvailability.defaultExpectation.params) {
			mmCheckChatAvailability.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckChatAvailability.defaultExpectation.params)
		}
	}

	return mmCheckChatAvailability
}

// Inspect accepts an inspector function that has same arguments as the ChatService.CheckChatAvailability
func (mmCheckChatAvailability *mChatServiceMockCheckChatAvailability) Inspect(f func(ctx context.Context, chatID int64, username string)) *mChatServiceMockCheckChatAvailability {
	if mmCheckChatAvailability.mock.inspectFuncCheckChatAvailability != nil {
		mmCheckChatAvailability.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.CheckChatAvailability")
	}

	mmCheckChatAvailability.mock.inspectFuncCheckChatAvailability = f

	return mmCheckChatAvailability
}

// Return sets up results that will be returned by ChatService.CheckChatAvailability
func (mmCheckChatAvailability *mChatServiceMockCheckChatAvailability) Return(err error) *ChatServiceMock {
	if mmCheckChatAvailability.mock.funcCheckChatAvailability != nil {
		mmCheckChatAvailability.mock.t.Fatalf("ChatServiceMock.CheckChatAvailability mock is already set by Set")
	}

	if mmCheckChatAvailability.defaultExpectation == nil {
		mmCheckChatAvailability.defaultExpectation = &ChatServiceMockCheckChatAvailabilityExpectation{mock: mmCheckChatAvailability.mock}
	}
	mmCheckChatAvailability.defaultExpectation.results = &ChatServiceMockCheckChatAvailabilityResults{err}
	return mmCheckChatAvailability.mock
}

// Set uses given function f to mock the ChatService.CheckChatAvailability method
func (mmCheckChatAvailability *mChatServiceMockCheckChatAvailability) Set(f func(ctx context.Context, chatID int64, username string) (err error)) *ChatServiceMock {
	if mmCheckChatAvailability.defaultExpectation != nil {
		mmCheckChatAvailability.mock.t.Fatalf("Default expectation is already set for the ChatService.CheckChatAvailability method")
	}

	if len(mmCheckChatAvailability.expectations) > 0 {
		mmCheckChatAvailability.mock.t.Fatalf("Some expectations are already set for the ChatService.CheckChatAvailability method")
	}

	mmCheckChatAvailability.mock.funcCheckChatAvailability = f
	return mmCheckChatAvailability.mock
}

// When sets expectation for the ChatService.CheckChatAvailability which will trigger the result defined by the following
// Then helper
func (mmCheckChatAvailability *mChatServiceMockCheckChatAvailability) When(ctx context.Context, chatID int64, username string) *ChatServiceMockCheckChatAvailabilityExpectation {
	if mmCheckChatAvailability.mock.funcCheckChatAvailability != nil {
		mmCheckChatAvailability.mock.t.Fatalf("ChatServiceMock.CheckChatAvailability mock is already set by Set")
	}

	expectation := &ChatServiceMockCheckChatAvailabilityExpectation{
		mock:   mmCheckChatAvailability.mock,
		params: &ChatServiceMockCheckChatAvailabilityParams{ctx, chatID, username},
	}
	mmCheckChatAvailability.expectations = append(mmCheckChatAvailability.expectations, expectation)
	return expectation
}

// Then sets up ChatService.CheckChatAvailability return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCheckChatAvailabilityExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockCheckChatAvailabilityResults{err}
	return e.mock
}

// CheckChatAvailability implements service.ChatService
func (mmCheckChatAvailability *ChatServiceMock) CheckChatAvailability(ctx context.Context, chatID int64, username string) (err error) {
	mm_atomic.AddUint64(&mmCheckChatAvailability.beforeCheckChatAvailabilityCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckChatAvailability.afterCheckChatAvailabilityCounter, 1)

	if mmCheckChatAvailability.inspectFuncCheckChatAvailability != nil {
		mmCheckChatAvailability.inspectFuncCheckChatAvailability(ctx, chatID, username)
	}

	mm_params := ChatServiceMockCheckChatAvailabilityParams{ctx, chatID, username}

	// Record call args
	mmCheckChatAvailability.CheckChatAvailabilityMock.mutex.Lock()
	mmCheckChatAvailability.CheckChatAvailabilityMock.callArgs = append(mmCheckChatAvailability.CheckChatAvailabilityMock.callArgs, &mm_params)
	mmCheckChatAvailability.CheckChatAvailabilityMock.mutex.Unlock()

	for _, e := range mmCheckChatAvailability.CheckChatAvailabilityMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckChatAvailability.CheckChatAvailabilityMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckChatAvailability.CheckChatAvailabilityMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckChatAvailability.CheckChatAvailabilityMock.defaultExpectation.params
		mm_got := ChatServiceMockCheckChatAvailabilityParams{ctx, chatID, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckChatAvailability.t.Errorf("ChatServiceMock.CheckChatAvailability got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckChatAvailability.CheckChatAvailabilityMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckChatAvailability.t.Fatal("No results are set for the ChatServiceMock.CheckChatAvailability")
		}
		return (*mm_results).err
	}
	if mmCheckChatAvailability.funcCheckChatAvailability != nil {
		return mmCheckChatAvailability.funcCheckChatAvailability(ctx, chatID, username)
	}
	mmCheckChatAvailability.t.Fatalf("Unexpected call to ChatServiceMock.CheckChatAvailability. %v %v %v", ctx, chatID, username)
	return
}

// CheckChatAvailabilityAfterCounter returns a count of finished ChatServiceMock.CheckChatAvailability invocations
func (mmCheckChatAvailability *ChatServiceMock) CheckChatAvailabilityAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckChatAvailability.afterCheckChatAvailabilityCounter)
}

// CheckChatAvailabilityBeforeCounter returns a count of ChatServiceMock.CheckChatAvailability invocations
func (mmCheckChatAvailability *ChatServiceMock) CheckChatAvailabilityBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckChatAvailability.beforeCheckChatAvailabilityCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.CheckChatAvailability.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckChatAvailability *mChatServiceMockCheckChatAvailability) Calls() []*ChatServiceMockCheckChatAvailabilityParams {
	mmCheckChatAvailability.mutex.RLock()

	argCopy := make([]*ChatServiceMockCheckChatAvailabilityParams, len(mmCheckChatAvailability.callArgs))
	copy(argCopy, mmCheckChatAvailability.callArgs)

	mmCheckChatAvailability.mutex.RUnlock()

	return argCopy
}

// MinimockCheckChatAvailabilityDone returns true if the count of the CheckChatAvailability invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCheckChatAvailabilityDone() bool {
	for _, e := range m.CheckChatAvailabilityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckChatAvailabilityMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckChatAvailabilityCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckChatAvailability != nil && mm_atomic.LoadUint64(&m.afterCheckChatAvailabilityCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckChatAvailabilityInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCheckChatAvailabilityInspect() {
	for _, e := range m.CheckChatAvailabilityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.CheckChatAvailability with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckChatAvailabilityMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckChatAvailabilityCounter) < 1 {
		if m.CheckChatAvailabilityMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.CheckChatAvailability")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.CheckChatAvailability with params: %#v", *m.CheckChatAvailabilityMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckChatAvailability != nil && mm_atomic.LoadUint64(&m.afterCheckChatAvailabilityCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.CheckChatAvailability")
	}
}

type mChatServiceMockCheckCtxUserChatAvailability struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCheckCtxUserChatAvailabilityExpectation
	expectations       []*ChatServiceMockCheckCtxUserChatAvailabilityExpectation

	callArgs []*ChatServiceMockCheckCtxUserChatAvailabilityParams
	mutex    sync.RWMutex
}

// ChatServiceMockCheckCtxUserChatAvailabilityExpectation specifies expectation struct of the ChatService.CheckCtxUserChatAvailability
type ChatServiceMockCheckCtxUserChatAvailabilityExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockCheckCtxUserChatAvailabilityParams
	results *ChatServiceMockCheckCtxUserChatAvailabilityResults
	Counter uint64
}

// ChatServiceMockCheckCtxUserChatAvailabilityParams contains parameters of the ChatService.CheckCtxUserChatAvailability
type ChatServiceMockCheckCtxUserChatAvailabilityParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServiceMockCheckCtxUserChatAvailabilityResults contains results of the ChatService.CheckCtxUserChatAvailability
type ChatServiceMockCheckCtxUserChatAvailabilityResults struct {
	err error
}

// Expect sets up expected params for ChatService.CheckCtxUserChatAvailability
func (mmCheckCtxUserChatAvailability *mChatServiceMockCheckCtxUserChatAvailability) Expect(ctx context.Context, chatID int64) *mChatServiceMockCheckCtxUserChatAvailability {
	if mmCheckCtxUserChatAvailability.mock.funcCheckCtxUserChatAvailability != nil {
		mmCheckCtxUserChatAvailability.mock.t.Fatalf("ChatServiceMock.CheckCtxUserChatAvailability mock is already set by Set")
	}

	if mmCheckCtxUserChatAvailability.defaultExpectation == nil {
		mmCheckCtxUserChatAvailability.defaultExpectation = &ChatServiceMockCheckCtxUserChatAvailabilityExpectation{}
	}

	mmCheckCtxUserChatAvailability.defaultExpectation.params = &ChatServiceMockCheckCtxUserChatAvailabilityParams{ctx, chatID}
	for _, e := range mmCheckCtxUserChatAvailability.expectations {
		if minimock.Equal(e.params, mmCheckCtxUserChatAvailability.defaultExpectation.params) {
			mmCheckCtxUserChatAvailability.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckCtxUserChatAvailability.defaultExpectation.params)
		}
	}

	return mmCheckCtxUserChatAvailability
}

// Inspect accepts an inspector function that has same arguments as the ChatService.CheckCtxUserChatAvailability
func (mmCheckCtxUserChatAvailability *mChatServiceMockCheckCtxUserChatAvailability) Inspect(f func(ctx context.Context, chatID int64)) *mChatServiceMockCheckCtxUserChatAvailability {
	if mmCheckCtxUserChatAvailability.mock.inspectFuncCheckCtxUserChatAvailability != nil {
		mmCheckCtxUserChatAvailability.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.CheckCtxUserChatAvailability")
	}

	mmCheckCtxUserChatAvailability.mock.inspectFuncCheckCtxUserChatAvailability = f

	return mmCheckCtxUserChatAvailability
}

// Return sets up results that will be returned by ChatService.CheckCtxUserChatAvailability
func (mmCheckCtxUserChatAvailability *mChatServiceMockCheckCtxUserChatAvailability) Return(err error) *ChatServiceMock {
	if mmCheckCtxUserChatAvailability.mock.funcCheckCtxUserChatAvailability != nil {
		mmCheckCtxUserChatAvailability.mock.t.Fatalf("ChatServiceMock.CheckCtxUserChatAvailability mock is already set by Set")
	}

	if mmCheckCtxUserChatAvailability.defaultExpectation == nil {
		mmCheckCtxUserChatAvailability.defaultExpectation = &ChatServiceMockCheckCtxUserChatAvailabilityExpectation{mock: mmCheckCtxUserChatAvailability.mock}
	}
	mmCheckCtxUserChatAvailability.defaultExpectation.results = &ChatServiceMockCheckCtxUserChatAvailabilityResults{err}
	return mmCheckCtxUserChatAvailability.mock
}

// Set uses given function f to mock the ChatService.CheckCtxUserChatAvailability method
func (mmCheckCtxUserChatAvailability *mChatServiceMockCheckCtxUserChatAvailability) Set(f func(ctx context.Context, chatID int64) (err error)) *ChatServiceMock {
	if mmCheckCtxUserChatAvailability.defaultExpectation != nil {
		mmCheckCtxUserChatAvailability.mock.t.Fatalf("Default expectation is already set for the ChatService.CheckCtxUserChatAvailability method")
	}

	if len(mmCheckCtxUserChatAvailability.expectations) > 0 {
		mmCheckCtxUserChatAvailability.mock.t.Fatalf("Some expectations are already set for the ChatService.CheckCtxUserChatAvailability method")
	}

	mmCheckCtxUserChatAvailability.mock.funcCheckCtxUserChatAvailability = f
	return mmCheckCtxUserChatAvailability.mock
}

// When sets expectation for the ChatService.CheckCtxUserChatAvailability which will trigger the result defined by the following
// Then helper
func (mmCheckCtxUserChatAvailability *mChatServiceMockCheckCtxUserChatAvailability) When(ctx context.Context, chatID int64) *ChatServiceMockCheckCtxUserChatAvailabilityExpectation {
	if mmCheckCtxUserChatAvailability.mock.funcCheckCtxUserChatAvailability != nil {
		mmCheckCtxUserChatAvailability.mock.t.Fatalf("ChatServiceMock.CheckCtxUserChatAvailability mock is already set by Set")
	}

	expectation := &ChatServiceMockCheckCtxUserChatAvailabilityExpectation{
		mock:   mmCheckCtxUserChatAvailability.mock,
		params: &ChatServiceMockCheckCtxUserChatAvailabilityParams{ctx, chatID},
	}
	mmCheckCtxUserChatAvailability.expectations = append(mmCheckCtxUserChatAvailability.expectations, expectation)
	return expectation
}

// Then sets up ChatService.CheckCtxUserChatAvailability return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCheckCtxUserChatAvailabilityExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockCheckCtxUserChatAvailabilityResults{err}
	return e.mock
}

// CheckCtxUserChatAvailability implements service.ChatService
func (mmCheckCtxUserChatAvailability *ChatServiceMock) CheckCtxUserChatAvailability(ctx context.Context, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmCheckCtxUserChatAvailability.beforeCheckCtxUserChatAvailabilityCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckCtxUserChatAvailability.afterCheckCtxUserChatAvailabilityCounter, 1)

	if mmCheckCtxUserChatAvailability.inspectFuncCheckCtxUserChatAvailability != nil {
		mmCheckCtxUserChatAvailability.inspectFuncCheckCtxUserChatAvailability(ctx, chatID)
	}

	mm_params := ChatServiceMockCheckCtxUserChatAvailabilityParams{ctx, chatID}

	// Record call args
	mmCheckCtxUserChatAvailability.CheckCtxUserChatAvailabilityMock.mutex.Lock()
	mmCheckCtxUserChatAvailability.CheckCtxUserChatAvailabilityMock.callArgs = append(mmCheckCtxUserChatAvailability.CheckCtxUserChatAvailabilityMock.callArgs, &mm_params)
	mmCheckCtxUserChatAvailability.CheckCtxUserChatAvailabilityMock.mutex.Unlock()

	for _, e := range mmCheckCtxUserChatAvailability.CheckCtxUserChatAvailabilityMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckCtxUserChatAvailability.CheckCtxUserChatAvailabilityMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckCtxUserChatAvailability.CheckCtxUserChatAvailabilityMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckCtxUserChatAvailability.CheckCtxUserChatAvailabilityMock.defaultExpectation.params
		mm_got := ChatServiceMockCheckCtxUserChatAvailabilityParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckCtxUserChatAvailability.t.Errorf("ChatServiceMock.CheckCtxUserChatAvailability got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckCtxUserChatAvailability.CheckCtxUserChatAvailabilityMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckCtxUserChatAvailability.t.Fatal("No results are set for the ChatServiceMock.CheckCtxUserChatAvailability")
		}
		return (*mm_results).err
	}
	if mmCheckCtxUserChatAvailability.funcCheckCtxUserChatAvailability != nil {
		return mmCheckCtxUserChatAvailability.funcCheckCtxUserChatAvailability(ctx, chatID)
	}
	mmCheckCtxUserChatAvailability.t.Fatalf("Unexpected call to ChatServiceMock.CheckCtxUserChatAvailability. %v %v", ctx, chatID)
	return
}

// CheckCtxUserChatAvailabilityAfterCounter returns a count of finished ChatServiceMock.CheckCtxUserChatAvailability invocations
func (mmCheckCtxUserChatAvailability *ChatServiceMock) CheckCtxUserChatAvailabilityAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckCtxUserChatAvailability.afterCheckCtxUserChatAvailabilityCounter)
}

// CheckCtxUserChatAvailabilityBeforeCounter returns a count of ChatServiceMock.CheckCtxUserChatAvailability invocations
func (mmCheckCtxUserChatAvailability *ChatServiceMock) CheckCtxUserChatAvailabilityBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckCtxUserChatAvailability.beforeCheckCtxUserChatAvailabilityCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.CheckCtxUserChatAvailability.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckCtxUserChatAvailability *mChatServiceMockCheckCtxUserChatAvailability) Calls() []*ChatServiceMockCheckCtxUserChatAvailabilityParams {
	mmCheckCtxUserChatAvailability.mutex.RLock()

	argCopy := make([]*ChatServiceMockCheckCtxUserChatAvailabilityParams, len(mmCheckCtxUserChatAvailability.callArgs))
	copy(argCopy, mmCheckCtxUserChatAvailability.callArgs)

	mmCheckCtxUserChatAvailability.mutex.RUnlock()

	return argCopy
}

// MinimockCheckCtxUserChatAvailabilityDone returns true if the count of the CheckCtxUserChatAvailability invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCheckCtxUserChatAvailabilityDone() bool {
	for _, e := range m.CheckCtxUserChatAvailabilityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckCtxUserChatAvailabilityMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCtxUserChatAvailabilityCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckCtxUserChatAvailability != nil && mm_atomic.LoadUint64(&m.afterCheckCtxUserChatAvailabilityCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckCtxUserChatAvailabilityInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCheckCtxUserChatAvailabilityInspect() {
	for _, e := range m.CheckCtxUserChatAvailabilityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.CheckCtxUserChatAvailability with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckCtxUserChatAvailabilityMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCtxUserChatAvailabilityCounter) < 1 {
		if m.CheckCtxUserChatAvailabilityMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.CheckCtxUserChatAvailability")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.CheckCtxUserChatAvailability with params: %#v", *m.CheckCtxUserChatAvailabilityMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckCtxUserChatAvailability != nil && mm_atomic.LoadUint64(&m.afterCheckCtxUserChatAvailabilityCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.CheckCtxUserChatAvailability")
	}
}

type mChatServiceMockConnectChat struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockConnectChatExpectation
	expectations       []*ChatServiceMockConnectChatExpectation

	callArgs []*ChatServiceMockConnectChatParams
	mutex    sync.RWMutex
}

// ChatServiceMockConnectChatExpectation specifies expectation struct of the ChatService.ConnectChat
type ChatServiceMockConnectChatExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockConnectChatParams
	results *ChatServiceMockConnectChatResults
	Counter uint64
}

// ChatServiceMockConnectChatParams contains parameters of the ChatService.ConnectChat
type ChatServiceMockConnectChatParams struct {
	stream mm_service.Stream
	chatID int64
}

// ChatServiceMockConnectChatResults contains results of the ChatService.ConnectChat
type ChatServiceMockConnectChatResults struct {
	err error
}

// Expect sets up expected params for ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Expect(stream mm_service.Stream, chatID int64) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{}
	}

	mmConnectChat.defaultExpectation.params = &ChatServiceMockConnectChatParams{stream, chatID}
	for _, e := range mmConnectChat.expectations {
		if minimock.Equal(e.params, mmConnectChat.defaultExpectation.params) {
			mmConnectChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConnectChat.defaultExpectation.params)
		}
	}

	return mmConnectChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Inspect(f func(stream mm_service.Stream, chatID int64)) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.inspectFuncConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.ConnectChat")
	}

	mmConnectChat.mock.inspectFuncConnectChat = f

	return mmConnectChat
}

// Return sets up results that will be returned by ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Return(err error) *ChatServiceMock {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{mock: mmConnectChat.mock}
	}
	mmConnectChat.defaultExpectation.results = &ChatServiceMockConnectChatResults{err}
	return mmConnectChat.mock
}

// Set uses given function f to mock the ChatService.ConnectChat method
func (mmConnectChat *mChatServiceMockConnectChat) Set(f func(stream mm_service.Stream, chatID int64) (err error)) *ChatServiceMock {
	if mmConnectChat.defaultExpectation != nil {
		mmConnectChat.mock.t.Fatalf("Default expectation is already set for the ChatService.ConnectChat method")
	}

	if len(mmConnectChat.expectations) > 0 {
		mmConnectChat.mock.t.Fatalf("Some expectations are already set for the ChatService.ConnectChat method")
	}

	mmConnectChat.mock.funcConnectChat = f
	return mmConnectChat.mock
}

// When sets expectation for the ChatService.ConnectChat which will trigger the result defined by the following
// Then helper
func (mmConnectChat *mChatServiceMockConnectChat) When(stream mm_service.Stream, chatID int64) *ChatServiceMockConnectChatExpectation {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	expectation := &ChatServiceMockConnectChatExpectation{
		mock:   mmConnectChat.mock,
		params: &ChatServiceMockConnectChatParams{stream, chatID},
	}
	mmConnectChat.expectations = append(mmConnectChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.ConnectChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockConnectChatExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockConnectChatResults{err}
	return e.mock
}

// ConnectChat implements service.ChatService
func (mmConnectChat *ChatServiceMock) ConnectChat(stream mm_service.Stream, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmConnectChat.beforeConnectChatCounter, 1)
	defer mm_atomic.AddUint64(&mmConnectChat.afterConnectChatCounter, 1)

	if mmConnectChat.inspectFuncConnectChat != nil {
		mmConnectChat.inspectFuncConnectChat(stream, chatID)
	}

	mm_params := ChatServiceMockConnectChatParams{stream, chatID}

	// Record call args
	mmConnectChat.ConnectChatMock.mutex.Lock()
	mmConnectChat.ConnectChatMock.callArgs = append(mmConnectChat.ConnectChatMock.callArgs, &mm_params)
	mmConnectChat.ConnectChatMock.mutex.Unlock()

	for _, e := range mmConnectChat.ConnectChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmConnectChat.ConnectChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConnectChat.ConnectChatMock.defaultExpectation.Counter, 1)
		mm_want := mmConnectChat.ConnectChatMock.defaultExpectation.params
		mm_got := ChatServiceMockConnectChatParams{stream, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConnectChat.t.Errorf("ChatServiceMock.ConnectChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConnectChat.ConnectChatMock.defaultExpectation.results
		if mm_results == nil {
			mmConnectChat.t.Fatal("No results are set for the ChatServiceMock.ConnectChat")
		}
		return (*mm_results).err
	}
	if mmConnectChat.funcConnectChat != nil {
		return mmConnectChat.funcConnectChat(stream, chatID)
	}
	mmConnectChat.t.Fatalf("Unexpected call to ChatServiceMock.ConnectChat. %v %v", stream, chatID)
	return
}

// ConnectChatAfterCounter returns a count of finished ChatServiceMock.ConnectChat invocations
func (mmConnectChat *ChatServiceMock) ConnectChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnectChat.afterConnectChatCounter)
}

// ConnectChatBeforeCounter returns a count of ChatServiceMock.ConnectChat invocations
func (mmConnectChat *ChatServiceMock) ConnectChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnectChat.beforeConnectChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.ConnectChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConnectChat *mChatServiceMockConnectChat) Calls() []*ChatServiceMockConnectChatParams {
	mmConnectChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockConnectChatParams, len(mmConnectChat.callArgs))
	copy(argCopy, mmConnectChat.callArgs)

	mmConnectChat.mutex.RUnlock()

	return argCopy
}

// MinimockConnectChatDone returns true if the count of the ConnectChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockConnectChatDone() bool {
	for _, e := range m.ConnectChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnectChat != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockConnectChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockConnectChatInspect() {
	for _, e := range m.ConnectChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.ConnectChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		if m.ConnectChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.ConnectChat")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.ConnectChat with params: %#v", *m.ConnectChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnectChat != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.ConnectChat")
	}
}

type mChatServiceMockCreateChat struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCreateChatExpectation
	expectations       []*ChatServiceMockCreateChatExpectation

	callArgs []*ChatServiceMockCreateChatParams
	mutex    sync.RWMutex
}

// ChatServiceMockCreateChatExpectation specifies expectation struct of the ChatService.CreateChat
type ChatServiceMockCreateChatExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockCreateChatParams
	results *ChatServiceMockCreateChatResults
	Counter uint64
}

// ChatServiceMockCreateChatParams contains parameters of the ChatService.CreateChat
type ChatServiceMockCreateChatParams struct {
	ctx       context.Context
	usernames []string
	title     string
}

// ChatServiceMockCreateChatResults contains results of the ChatService.CreateChat
type ChatServiceMockCreateChatResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Expect(ctx context.Context, usernames []string, title string) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{}
	}

	mmCreateChat.defaultExpectation.params = &ChatServiceMockCreateChatParams{ctx, usernames, title}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Inspect(f func(ctx context.Context, usernames []string, title string)) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Return(i1 int64, err error) *ChatServiceMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatServiceMockCreateChatResults{i1, err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatService.CreateChat method
func (mmCreateChat *mChatServiceMockCreateChat) Set(f func(ctx context.Context, usernames []string, title string) (i1 int64, err error)) *ChatServiceMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatService.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatService.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the ChatService.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatServiceMockCreateChat) When(ctx context.Context, usernames []string, title string) *ChatServiceMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatServiceMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &ChatServiceMockCreateChatParams{ctx, usernames, title},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCreateChatExpectation) Then(i1 int64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockCreateChatResults{i1, err}
	return e.mock
}

// CreateChat implements service.ChatService
func (mmCreateChat *ChatServiceMock) CreateChat(ctx context.Context, usernames []string, title string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, usernames, title)
	}

	mm_params := ChatServiceMockCreateChatParams{ctx, usernames, title}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_got := ChatServiceMockCreateChatParams{ctx, usernames, title}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatServiceMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, usernames, title)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatServiceMock.CreateChat. %v %v %v", ctx, usernames, title)
	return
}

// CreateChatAfterCounter returns a count of finished ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatServiceMockCreateChat) Calls() []*ChatServiceMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCreateChatDone() bool {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.CreateChat")
	}
}

type mChatServiceMockDeleteChat struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockDeleteChatExpectation
	expectations       []*ChatServiceMockDeleteChatExpectation

	callArgs []*ChatServiceMockDeleteChatParams
	mutex    sync.RWMutex
}

// ChatServiceMockDeleteChatExpectation specifies expectation struct of the ChatService.DeleteChat
type ChatServiceMockDeleteChatExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockDeleteChatParams
	results *ChatServiceMockDeleteChatResults
	Counter uint64
}

// ChatServiceMockDeleteChatParams contains parameters of the ChatService.DeleteChat
type ChatServiceMockDeleteChatParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServiceMockDeleteChatResults contains results of the ChatService.DeleteChat
type ChatServiceMockDeleteChatResults struct {
	err error
}

// Expect sets up expected params for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Expect(ctx context.Context, chatID int64) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	mmDeleteChat.defaultExpectation.params = &ChatServiceMockDeleteChatParams{ctx, chatID}
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Inspect(f func(ctx context.Context, chatID int64)) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Return(err error) *ChatServiceMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatServiceMockDeleteChatResults{err}
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatService.DeleteChat method
func (mmDeleteChat *mChatServiceMockDeleteChat) Set(f func(ctx context.Context, chatID int64) (err error)) *ChatServiceMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatService.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatService.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	return mmDeleteChat.mock
}

// When sets expectation for the ChatService.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServiceMockDeleteChat) When(ctx context.Context, chatID int64) *ChatServiceMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatServiceMockDeleteChatExpectation{
		mock:   mmDeleteChat.mock,
		params: &ChatServiceMockDeleteChatParams{ctx, chatID},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockDeleteChatExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockDeleteChatResults{err}
	return e.mock
}

// DeleteChat implements service.ChatService
func (mmDeleteChat *ChatServiceMock) DeleteChat(ctx context.Context, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, chatID)
	}

	mm_params := ChatServiceMockDeleteChatParams{ctx, chatID}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_got := ChatServiceMockDeleteChatParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatServiceMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, chatID)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatServiceMock.DeleteChat. %v %v", ctx, chatID)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServiceMockDeleteChat) Calls() []*ChatServiceMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockDeleteChatDone() bool {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.DeleteChat")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.DeleteChat")
	}
}

type mChatServiceMockGetAvailableChatsAndCount struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetAvailableChatsAndCountExpectation
	expectations       []*ChatServiceMockGetAvailableChatsAndCountExpectation

	callArgs []*ChatServiceMockGetAvailableChatsAndCountParams
	mutex    sync.RWMutex
}

// ChatServiceMockGetAvailableChatsAndCountExpectation specifies expectation struct of the ChatService.GetAvailableChatsAndCount
type ChatServiceMockGetAvailableChatsAndCountExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockGetAvailableChatsAndCountParams
	results *ChatServiceMockGetAvailableChatsAndCountResults
	Counter uint64
}

// ChatServiceMockGetAvailableChatsAndCountParams contains parameters of the ChatService.GetAvailableChatsAndCount
type ChatServiceMockGetAvailableChatsAndCountParams struct {
	ctx      context.Context
	page     int64
	pageSize int64
}

// ChatServiceMockGetAvailableChatsAndCountResults contains results of the ChatService.GetAvailableChatsAndCount
type ChatServiceMockGetAvailableChatsAndCountResults struct {
	cpa1 []*serviceModel.Chat
	u1   uint64
	err  error
}

// Expect sets up expected params for ChatService.GetAvailableChatsAndCount
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) Expect(ctx context.Context, page int64, pageSize int64) *mChatServiceMockGetAvailableChatsAndCount {
	if mmGetAvailableChatsAndCount.mock.funcGetAvailableChatsAndCount != nil {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("ChatServiceMock.GetAvailableChatsAndCount mock is already set by Set")
	}

	if mmGetAvailableChatsAndCount.defaultExpectation == nil {
		mmGetAvailableChatsAndCount.defaultExpectation = &ChatServiceMockGetAvailableChatsAndCountExpectation{}
	}

	mmGetAvailableChatsAndCount.defaultExpectation.params = &ChatServiceMockGetAvailableChatsAndCountParams{ctx, page, pageSize}
	for _, e := range mmGetAvailableChatsAndCount.expectations {
		if minimock.Equal(e.params, mmGetAvailableChatsAndCount.defaultExpectation.params) {
			mmGetAvailableChatsAndCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAvailableChatsAndCount.defaultExpectation.params)
		}
	}

	return mmGetAvailableChatsAndCount
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetAvailableChatsAndCount
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) Inspect(f func(ctx context.Context, page int64, pageSize int64)) *mChatServiceMockGetAvailableChatsAndCount {
	if mmGetAvailableChatsAndCount.mock.inspectFuncGetAvailableChatsAndCount != nil {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetAvailableChatsAndCount")
	}

	mmGetAvailableChatsAndCount.mock.inspectFuncGetAvailableChatsAndCount = f

	return mmGetAvailableChatsAndCount
}

// Return sets up results that will be returned by ChatService.GetAvailableChatsAndCount
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) Return(cpa1 []*serviceModel.Chat, u1 uint64, err error) *ChatServiceMock {
	if mmGetAvailableChatsAndCount.mock.funcGetAvailableChatsAndCount != nil {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("ChatServiceMock.GetAvailableChatsAndCount mock is already set by Set")
	}

	if mmGetAvailableChatsAndCount.defaultExpectation == nil {
		mmGetAvailableChatsAndCount.defaultExpectation = &ChatServiceMockGetAvailableChatsAndCountExpectation{mock: mmGetAvailableChatsAndCount.mock}
	}
	mmGetAvailableChatsAndCount.defaultExpectation.results = &ChatServiceMockGetAvailableChatsAndCountResults{cpa1, u1, err}
	return mmGetAvailableChatsAndCount.mock
}

// Set uses given function f to mock the ChatService.GetAvailableChatsAndCount method
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) Set(f func(ctx context.Context, page int64, pageSize int64) (cpa1 []*serviceModel.Chat, u1 uint64, err error)) *ChatServiceMock {
	if mmGetAvailableChatsAndCount.defaultExpectation != nil {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("Default expectation is already set for the ChatService.GetAvailableChatsAndCount method")
	}

	if len(mmGetAvailableChatsAndCount.expectations) > 0 {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("Some expectations are already set for the ChatService.GetAvailableChatsAndCount method")
	}

	mmGetAvailableChatsAndCount.mock.funcGetAvailableChatsAndCount = f
	return mmGetAvailableChatsAndCount.mock
}

// When sets expectation for the ChatService.GetAvailableChatsAndCount which will trigger the result defined by the following
// Then helper
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) When(ctx context.Context, page int64, pageSize int64) *ChatServiceMockGetAvailableChatsAndCountExpectation {
	if mmGetAvailableChatsAndCount.mock.funcGetAvailableChatsAndCount != nil {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("ChatServiceMock.GetAvailableChatsAndCount mock is already set by Set")
	}

	expectation := &ChatServiceMockGetAvailableChatsAndCountExpectation{
		mock:   mmGetAvailableChatsAndCount.mock,
		params: &ChatServiceMockGetAvailableChatsAndCountParams{ctx, page, pageSize},
	}
	mmGetAvailableChatsAndCount.expectations = append(mmGetAvailableChatsAndCount.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetAvailableChatsAndCount return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetAvailableChatsAndCountExpectation) Then(cpa1 []*serviceModel.Chat, u1 uint64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetAvailableChatsAndCountResults{cpa1, u1, err}
	return e.mock
}

// GetAvailableChatsAndCount implements service.ChatService
func (mmGetAvailableChatsAndCount *ChatServiceMock) GetAvailableChatsAndCount(ctx context.Context, page int64, pageSize int64) (cpa1 []*serviceModel.Chat, u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetAvailableChatsAndCount.beforeGetAvailableChatsAndCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAvailableChatsAndCount.afterGetAvailableChatsAndCountCounter, 1)

	if mmGetAvailableChatsAndCount.inspectFuncGetAvailableChatsAndCount != nil {
		mmGetAvailableChatsAndCount.inspectFuncGetAvailableChatsAndCount(ctx, page, pageSize)
	}

	mm_params := ChatServiceMockGetAvailableChatsAndCountParams{ctx, page, pageSize}

	// Record call args
	mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.mutex.Lock()
	mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.callArgs = append(mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.callArgs, &mm_params)
	mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.mutex.Unlock()

	for _, e := range mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.u1, e.results.err
		}
	}

	if mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.defaultExpectation.params
		mm_got := ChatServiceMockGetAvailableChatsAndCountParams{ctx, page, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAvailableChatsAndCount.t.Errorf("ChatServiceMock.GetAvailableChatsAndCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAvailableChatsAndCount.t.Fatal("No results are set for the ChatServiceMock.GetAvailableChatsAndCount")
		}
		return (*mm_results).cpa1, (*mm_results).u1, (*mm_results).err
	}
	if mmGetAvailableChatsAndCount.funcGetAvailableChatsAndCount != nil {
		return mmGetAvailableChatsAndCount.funcGetAvailableChatsAndCount(ctx, page, pageSize)
	}
	mmGetAvailableChatsAndCount.t.Fatalf("Unexpected call to ChatServiceMock.GetAvailableChatsAndCount. %v %v %v", ctx, page, pageSize)
	return
}

// GetAvailableChatsAndCountAfterCounter returns a count of finished ChatServiceMock.GetAvailableChatsAndCount invocations
func (mmGetAvailableChatsAndCount *ChatServiceMock) GetAvailableChatsAndCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAvailableChatsAndCount.afterGetAvailableChatsAndCountCounter)
}

// GetAvailableChatsAndCountBeforeCounter returns a count of ChatServiceMock.GetAvailableChatsAndCount invocations
func (mmGetAvailableChatsAndCount *ChatServiceMock) GetAvailableChatsAndCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAvailableChatsAndCount.beforeGetAvailableChatsAndCountCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetAvailableChatsAndCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) Calls() []*ChatServiceMockGetAvailableChatsAndCountParams {
	mmGetAvailableChatsAndCount.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetAvailableChatsAndCountParams, len(mmGetAvailableChatsAndCount.callArgs))
	copy(argCopy, mmGetAvailableChatsAndCount.callArgs)

	mmGetAvailableChatsAndCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetAvailableChatsAndCountDone returns true if the count of the GetAvailableChatsAndCount invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetAvailableChatsAndCountDone() bool {
	for _, e := range m.GetAvailableChatsAndCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAvailableChatsAndCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAvailableChatsAndCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAvailableChatsAndCount != nil && mm_atomic.LoadUint64(&m.afterGetAvailableChatsAndCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAvailableChatsAndCountInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetAvailableChatsAndCountInspect() {
	for _, e := range m.GetAvailableChatsAndCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetAvailableChatsAndCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAvailableChatsAndCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAvailableChatsAndCountCounter) < 1 {
		if m.GetAvailableChatsAndCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.GetAvailableChatsAndCount")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetAvailableChatsAndCount with params: %#v", *m.GetAvailableChatsAndCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAvailableChatsAndCount != nil && mm_atomic.LoadUint64(&m.afterGetAvailableChatsAndCountCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.GetAvailableChatsAndCount")
	}
}

type mChatServiceMockGetChannels struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetChannelsExpectation
	expectations       []*ChatServiceMockGetChannelsExpectation
}

// ChatServiceMockGetChannelsExpectation specifies expectation struct of the ChatService.GetChannels
type ChatServiceMockGetChannelsExpectation struct {
	mock *ChatServiceMock

	results *ChatServiceMockGetChannelsResults
	Counter uint64
}

// ChatServiceMockGetChannelsResults contains results of the ChatService.GetChannels
type ChatServiceMockGetChannelsResults struct {
	m1 map[int64]chan *serviceModel.ChatMessage
}

// Expect sets up expected params for ChatService.GetChannels
func (mmGetChannels *mChatServiceMockGetChannels) Expect() *mChatServiceMockGetChannels {
	if mmGetChannels.mock.funcGetChannels != nil {
		mmGetChannels.mock.t.Fatalf("ChatServiceMock.GetChannels mock is already set by Set")
	}

	if mmGetChannels.defaultExpectation == nil {
		mmGetChannels.defaultExpectation = &ChatServiceMockGetChannelsExpectation{}
	}

	return mmGetChannels
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetChannels
func (mmGetChannels *mChatServiceMockGetChannels) Inspect(f func()) *mChatServiceMockGetChannels {
	if mmGetChannels.mock.inspectFuncGetChannels != nil {
		mmGetChannels.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetChannels")
	}

	mmGetChannels.mock.inspectFuncGetChannels = f

	return mmGetChannels
}

// Return sets up results that will be returned by ChatService.GetChannels
func (mmGetChannels *mChatServiceMockGetChannels) Return(m1 map[int64]chan *serviceModel.ChatMessage) *ChatServiceMock {
	if mmGetChannels.mock.funcGetChannels != nil {
		mmGetChannels.mock.t.Fatalf("ChatServiceMock.GetChannels mock is already set by Set")
	}

	if mmGetChannels.defaultExpectation == nil {
		mmGetChannels.defaultExpectation = &ChatServiceMockGetChannelsExpectation{mock: mmGetChannels.mock}
	}
	mmGetChannels.defaultExpectation.results = &ChatServiceMockGetChannelsResults{m1}
	return mmGetChannels.mock
}

// Set uses given function f to mock the ChatService.GetChannels method
func (mmGetChannels *mChatServiceMockGetChannels) Set(f func() (m1 map[int64]chan *serviceModel.ChatMessage)) *ChatServiceMock {
	if mmGetChannels.defaultExpectation != nil {
		mmGetChannels.mock.t.Fatalf("Default expectation is already set for the ChatService.GetChannels method")
	}

	if len(mmGetChannels.expectations) > 0 {
		mmGetChannels.mock.t.Fatalf("Some expectations are already set for the ChatService.GetChannels method")
	}

	mmGetChannels.mock.funcGetChannels = f
	return mmGetChannels.mock
}

// GetChannels implements service.ChatService
func (mmGetChannels *ChatServiceMock) GetChannels() (m1 map[int64]chan *serviceModel.ChatMessage) {
	mm_atomic.AddUint64(&mmGetChannels.beforeGetChannelsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChannels.afterGetChannelsCounter, 1)

	if mmGetChannels.inspectFuncGetChannels != nil {
		mmGetChannels.inspectFuncGetChannels()
	}

	if mmGetChannels.GetChannelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChannels.GetChannelsMock.defaultExpectation.Counter, 1)

		mm_results := mmGetChannels.GetChannelsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChannels.t.Fatal("No results are set for the ChatServiceMock.GetChannels")
		}
		return (*mm_results).m1
	}
	if mmGetChannels.funcGetChannels != nil {
		return mmGetChannels.funcGetChannels()
	}
	mmGetChannels.t.Fatalf("Unexpected call to ChatServiceMock.GetChannels.")
	return
}

// GetChannelsAfterCounter returns a count of finished ChatServiceMock.GetChannels invocations
func (mmGetChannels *ChatServiceMock) GetChannelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChannels.afterGetChannelsCounter)
}

// GetChannelsBeforeCounter returns a count of ChatServiceMock.GetChannels invocations
func (mmGetChannels *ChatServiceMock) GetChannelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChannels.beforeGetChannelsCounter)
}

// MinimockGetChannelsDone returns true if the count of the GetChannels invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetChannelsDone() bool {
	for _, e := range m.GetChannelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChannelsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChannelsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChannels != nil && mm_atomic.LoadUint64(&m.afterGetChannelsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetChannelsInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetChannelsInspect() {
	for _, e := range m.GetChannelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ChatServiceMock.GetChannels")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChannelsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChannelsCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.GetChannels")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChannels != nil && mm_atomic.LoadUint64(&m.afterGetChannelsCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.GetChannels")
	}
}

type mChatServiceMockGetChatMessagesAndCount struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetChatMessagesAndCountExpectation
	expectations       []*ChatServiceMockGetChatMessagesAndCountExpectation

	callArgs []*ChatServiceMockGetChatMessagesAndCountParams
	mutex    sync.RWMutex
}

// ChatServiceMockGetChatMessagesAndCountExpectation specifies expectation struct of the ChatService.GetChatMessagesAndCount
type ChatServiceMockGetChatMessagesAndCountExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockGetChatMessagesAndCountParams
	results *ChatServiceMockGetChatMessagesAndCountResults
	Counter uint64
}

// ChatServiceMockGetChatMessagesAndCountParams contains parameters of the ChatService.GetChatMessagesAndCount
type ChatServiceMockGetChatMessagesAndCountParams struct {
	ctx      context.Context
	chatID   int64
	page     int64
	pageSize int64
}

// ChatServiceMockGetChatMessagesAndCountResults contains results of the ChatService.GetChatMessagesAndCount
type ChatServiceMockGetChatMessagesAndCountResults struct {
	cpa1 []*serviceModel.ChatMessage
	u1   uint64
	err  error
}

// Expect sets up expected params for ChatService.GetChatMessagesAndCount
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) Expect(ctx context.Context, chatID int64, page int64, pageSize int64) *mChatServiceMockGetChatMessagesAndCount {
	if mmGetChatMessagesAndCount.mock.funcGetChatMessagesAndCount != nil {
		mmGetChatMessagesAndCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesAndCount mock is already set by Set")
	}

	if mmGetChatMessagesAndCount.defaultExpectation == nil {
		mmGetChatMessagesAndCount.defaultExpectation = &ChatServiceMockGetChatMessagesAndCountExpectation{}
	}

	mmGetChatMessagesAndCount.defaultExpectation.params = &ChatServiceMockGetChatMessagesAndCountParams{ctx, chatID, page, pageSize}
	for _, e := range mmGetChatMessagesAndCount.expectations {
		if minimock.Equal(e.params, mmGetChatMessagesAndCount.defaultExpectation.params) {
			mmGetChatMessagesAndCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatMessagesAndCount.defaultExpectation.params)
		}
	}

	return mmGetChatMessagesAndCount
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetChatMessagesAndCount
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) Inspect(f func(ctx context.Context, chatID int64, page int64, pageSize int64)) *mChatServiceMockGetChatMessagesAndCount {
	if mmGetChatMessagesAndCount.mock.inspectFuncGetChatMessagesAndCount != nil {
		mmGetChatMessagesAndCount.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetChatMessagesAndCount")
	}

	mmGetChatMessagesAndCount.mock.inspectFuncGetChatMessagesAndCount = f

	return mmGetChatMessagesAndCount
}

// Return sets up results that will be returned by ChatService.GetChatMessagesAndCount
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) Return(cpa1 []*serviceModel.ChatMessage, u1 uint64, err error) *ChatServiceMock {
	if mmGetChatMessagesAndCount.mock.funcGetChatMessagesAndCount != nil {
		mmGetChatMessagesAndCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesAndCount mock is already set by Set")
	}

	if mmGetChatMessagesAndCount.defaultExpectation == nil {
		mmGetChatMessagesAndCount.defaultExpectation = &ChatServiceMockGetChatMessagesAndCountExpectation{mock: mmGetChatMessagesAndCount.mock}
	}
	mmGetChatMessagesAndCount.defaultExpectation.results = &ChatServiceMockGetChatMessagesAndCountResults{cpa1, u1, err}
	return mmGetChatMessagesAndCount.mock
}

// Set uses given function f to mock the ChatService.GetChatMessagesAndCount method
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) Set(f func(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, u1 uint64, err error)) *ChatServiceMock {
	if mmGetChatMessagesAndCount.defaultExpectation != nil {
		mmGetChatMessagesAndCount.mock.t.Fatalf("Default expectation is already set for the ChatService.GetChatMessagesAndCount method")
	}

	if len(mmGetChatMessagesAndCount.expectations) > 0 {
		mmGetChatMessagesAndCount.mock.t.Fatalf("Some expectations are already set for the ChatService.GetChatMessagesAndCount method")
	}

	mmGetChatMessagesAndCount.mock.funcGetChatMessagesAndCount = f
	return mmGetChatMessagesAndCount.mock
}

// When sets expectation for the ChatService.GetChatMessagesAndCount which will trigger the result defined by the following
// Then helper
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) When(ctx context.Context, chatID int64, page int64, pageSize int64) *ChatServiceMockGetChatMessagesAndCountExpectation {
	if mmGetChatMessagesAndCount.mock.funcGetChatMessagesAndCount != nil {
		mmGetChatMessagesAndCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesAndCount mock is already set by Set")
	}

	expectation := &ChatServiceMockGetChatMessagesAndCountExpectation{
		mock:   mmGetChatMessagesAndCount.mock,
		params: &ChatServiceMockGetChatMessagesAndCountParams{ctx, chatID, page, pageSize},
	}
	mmGetChatMessagesAndCount.expectations = append(mmGetChatMessagesAndCount.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetChatMessagesAndCount return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetChatMessagesAndCountExpectation) Then(cpa1 []*serviceModel.ChatMessage, u1 uint64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetChatMessagesAndCountResults{cpa1, u1, err}
	return e.mock
}

// GetChatMessagesAndCount implements service.ChatService
func (mmGetChatMessagesAndCount *ChatServiceMock) GetChatMessagesAndCount(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetChatMessagesAndCount.beforeGetChatMessagesAndCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatMessagesAndCount.afterGetChatMessagesAndCountCounter, 1)

	if mmGetChatMessagesAndCount.inspectFuncGetChatMessagesAndCount != nil {
		mmGetChatMessagesAndCount.inspectFuncGetChatMessagesAndCount(ctx, chatID, page, pageSize)
	}

	mm_params := ChatServiceMockGetChatMessagesAndCountParams{ctx, chatID, page, pageSize}

	// Record call args
	mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.mutex.Lock()
	mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.callArgs = append(mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.callArgs, &mm_params)
	mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.mutex.Unlock()

	for _, e := range mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.u1, e.results.err
		}
	}

	if mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.defaultExpectation.params
		mm_got := ChatServiceMockGetChatMessagesAndCountParams{ctx, chatID, page, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatMessagesAndCount.t.Errorf("ChatServiceMock.GetChatMessagesAndCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatMessagesAndCount.t.Fatal("No results are set for the ChatServiceMock.GetChatMessagesAndCount")
		}
		return (*mm_results).cpa1, (*mm_results).u1, (*mm_results).err
	}
	if mmGetChatMessagesAndCount.funcGetChatMessagesAndCount != nil {
		return mmGetChatMessagesAndCount.funcGetChatMessagesAndCount(ctx, chatID, page, pageSize)
	}
	mmGetChatMessagesAndCount.t.Fatalf("Unexpected call to ChatServiceMock.GetChatMessagesAndCount. %v %v %v %v", ctx, chatID, page, pageSize)
	return
}

// GetChatMessagesAndCountAfterCounter returns a count of finished ChatServiceMock.GetChatMessagesAndCount invocations
func (mmGetChatMessagesAndCount *ChatServiceMock) GetChatMessagesAndCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessagesAndCount.afterGetChatMessagesAndCountCounter)
}

// GetChatMessagesAndCountBeforeCounter returns a count of ChatServiceMock.GetChatMessagesAndCount invocations
func (mmGetChatMessagesAndCount *ChatServiceMock) GetChatMessagesAndCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessagesAndCount.beforeGetChatMessagesAndCountCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetChatMessagesAndCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) Calls() []*ChatServiceMockGetChatMessagesAndCountParams {
	mmGetChatMessagesAndCount.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetChatMessagesAndCountParams, len(mmGetChatMessagesAndCount.callArgs))
	copy(argCopy, mmGetChatMessagesAndCount.callArgs)

	mmGetChatMessagesAndCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatMessagesAndCountDone returns true if the count of the GetChatMessagesAndCount invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetChatMessagesAndCountDone() bool {
	for _, e := range m.GetChatMessagesAndCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesAndCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesAndCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessagesAndCount != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesAndCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetChatMessagesAndCountInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetChatMessagesAndCountInspect() {
	for _, e := range m.GetChatMessagesAndCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessagesAndCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesAndCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesAndCountCounter) < 1 {
		if m.GetChatMessagesAndCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.GetChatMessagesAndCount")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessagesAndCount with params: %#v", *m.GetChatMessagesAndCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessagesAndCount != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesAndCountCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.GetChatMessagesAndCount")
	}
}

type mChatServiceMockInitMessagesChan struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockInitMessagesChanExpectation
	expectations       []*ChatServiceMockInitMessagesChanExpectation

	callArgs []*ChatServiceMockInitMessagesChanParams
	mutex    sync.RWMutex
}

// ChatServiceMockInitMessagesChanExpectation specifies expectation struct of the ChatService.InitMessagesChan
type ChatServiceMockInitMessagesChanExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockInitMessagesChanParams
	results *ChatServiceMockInitMessagesChanResults
	Counter uint64
}

// ChatServiceMockInitMessagesChanParams contains parameters of the ChatService.InitMessagesChan
type ChatServiceMockInitMessagesChanParams struct {
	chatID int64
}

// ChatServiceMockInitMessagesChanResults contains results of the ChatService.InitMessagesChan
type ChatServiceMockInitMessagesChanResults struct {
	ch1 chan *serviceModel.ChatMessage
}

// Expect sets up expected params for ChatService.InitMessagesChan
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) Expect(chatID int64) *mChatServiceMockInitMessagesChan {
	if mmInitMessagesChan.mock.funcInitMessagesChan != nil {
		mmInitMessagesChan.mock.t.Fatalf("ChatServiceMock.InitMessagesChan mock is already set by Set")
	}

	if mmInitMessagesChan.defaultExpectation == nil {
		mmInitMessagesChan.defaultExpectation = &ChatServiceMockInitMessagesChanExpectation{}
	}

	mmInitMessagesChan.defaultExpectation.params = &ChatServiceMockInitMessagesChanParams{chatID}
	for _, e := range mmInitMessagesChan.expectations {
		if minimock.Equal(e.params, mmInitMessagesChan.defaultExpectation.params) {
			mmInitMessagesChan.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitMessagesChan.defaultExpectation.params)
		}
	}

	return mmInitMessagesChan
}

// Inspect accepts an inspector function that has same arguments as the ChatService.InitMessagesChan
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) Inspect(f func(chatID int64)) *mChatServiceMockInitMessagesChan {
	if mmInitMessagesChan.mock.inspectFuncInitMessagesChan != nil {
		mmInitMessagesChan.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.InitMessagesChan")
	}

	mmInitMessagesChan.mock.inspectFuncInitMessagesChan = f

	return mmInitMessagesChan
}

// Return sets up results that will be returned by ChatService.InitMessagesChan
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) Return(ch1 chan *serviceModel.ChatMessage) *ChatServiceMock {
	if mmInitMessagesChan.mock.funcInitMessagesChan != nil {
		mmInitMessagesChan.mock.t.Fatalf("ChatServiceMock.InitMessagesChan mock is already set by Set")
	}

	if mmInitMessagesChan.defaultExpectation == nil {
		mmInitMessagesChan.defaultExpectation = &ChatServiceMockInitMessagesChanExpectation{mock: mmInitMessagesChan.mock}
	}
	mmInitMessagesChan.defaultExpectation.results = &ChatServiceMockInitMessagesChanResults{ch1}
	return mmInitMessagesChan.mock
}

// Set uses given function f to mock the ChatService.InitMessagesChan method
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) Set(f func(chatID int64) (ch1 chan *serviceModel.ChatMessage)) *ChatServiceMock {
	if mmInitMessagesChan.defaultExpectation != nil {
		mmInitMessagesChan.mock.t.Fatalf("Default expectation is already set for the ChatService.InitMessagesChan method")
	}

	if len(mmInitMessagesChan.expectations) > 0 {
		mmInitMessagesChan.mock.t.Fatalf("Some expectations are already set for the ChatService.InitMessagesChan method")
	}

	mmInitMessagesChan.mock.funcInitMessagesChan = f
	return mmInitMessagesChan.mock
}

// When sets expectation for the ChatService.InitMessagesChan which will trigger the result defined by the following
// Then helper
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) When(chatID int64) *ChatServiceMockInitMessagesChanExpectation {
	if mmInitMessagesChan.mock.funcInitMessagesChan != nil {
		mmInitMessagesChan.mock.t.Fatalf("ChatServiceMock.InitMessagesChan mock is already set by Set")
	}

	expectation := &ChatServiceMockInitMessagesChanExpectation{
		mock:   mmInitMessagesChan.mock,
		params: &ChatServiceMockInitMessagesChanParams{chatID},
	}
	mmInitMessagesChan.expectations = append(mmInitMessagesChan.expectations, expectation)
	return expectation
}

// Then sets up ChatService.InitMessagesChan return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockInitMessagesChanExpectation) Then(ch1 chan *serviceModel.ChatMessage) *ChatServiceMock {
	e.results = &ChatServiceMockInitMessagesChanResults{ch1}
	return e.mock
}

// InitMessagesChan implements service.ChatService
func (mmInitMessagesChan *ChatServiceMock) InitMessagesChan(chatID int64) (ch1 chan *serviceModel.ChatMessage) {
	mm_atomic.AddUint64(&mmInitMessagesChan.beforeInitMessagesChanCounter, 1)
	defer mm_atomic.AddUint64(&mmInitMessagesChan.afterInitMessagesChanCounter, 1)

	if mmInitMessagesChan.inspectFuncInitMessagesChan != nil {
		mmInitMessagesChan.inspectFuncInitMessagesChan(chatID)
	}

	mm_params := ChatServiceMockInitMessagesChanParams{chatID}

	// Record call args
	mmInitMessagesChan.InitMessagesChanMock.mutex.Lock()
	mmInitMessagesChan.InitMessagesChanMock.callArgs = append(mmInitMessagesChan.InitMessagesChanMock.callArgs, &mm_params)
	mmInitMessagesChan.InitMessagesChanMock.mutex.Unlock()

	for _, e := range mmInitMessagesChan.InitMessagesChanMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ch1
		}
	}

	if mmInitMessagesChan.InitMessagesChanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitMessagesChan.InitMessagesChanMock.defaultExpectation.Counter, 1)
		mm_want := mmInitMessagesChan.InitMessagesChanMock.defaultExpectation.params
		mm_got := ChatServiceMockInitMessagesChanParams{chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitMessagesChan.t.Errorf("ChatServiceMock.InitMessagesChan got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInitMessagesChan.InitMessagesChanMock.defaultExpectation.results
		if mm_results == nil {
			mmInitMessagesChan.t.Fatal("No results are set for the ChatServiceMock.InitMessagesChan")
		}
		return (*mm_results).ch1
	}
	if mmInitMessagesChan.funcInitMessagesChan != nil {
		return mmInitMessagesChan.funcInitMessagesChan(chatID)
	}
	mmInitMessagesChan.t.Fatalf("Unexpected call to ChatServiceMock.InitMessagesChan. %v", chatID)
	return
}

// InitMessagesChanAfterCounter returns a count of finished ChatServiceMock.InitMessagesChan invocations
func (mmInitMessagesChan *ChatServiceMock) InitMessagesChanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitMessagesChan.afterInitMessagesChanCounter)
}

// InitMessagesChanBeforeCounter returns a count of ChatServiceMock.InitMessagesChan invocations
func (mmInitMessagesChan *ChatServiceMock) InitMessagesChanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitMessagesChan.beforeInitMessagesChanCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.InitMessagesChan.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) Calls() []*ChatServiceMockInitMessagesChanParams {
	mmInitMessagesChan.mutex.RLock()

	argCopy := make([]*ChatServiceMockInitMessagesChanParams, len(mmInitMessagesChan.callArgs))
	copy(argCopy, mmInitMessagesChan.callArgs)

	mmInitMessagesChan.mutex.RUnlock()

	return argCopy
}

// MinimockInitMessagesChanDone returns true if the count of the InitMessagesChan invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockInitMessagesChanDone() bool {
	for _, e := range m.InitMessagesChanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMessagesChanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitMessagesChanCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitMessagesChan != nil && mm_atomic.LoadUint64(&m.afterInitMessagesChanCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitMessagesChanInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockInitMessagesChanInspect() {
	for _, e := range m.InitMessagesChanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.InitMessagesChan with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMessagesChanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitMessagesChanCounter) < 1 {
		if m.InitMessagesChanMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.InitMessagesChan")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.InitMessagesChan with params: %#v", *m.InitMessagesChanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitMessagesChan != nil && mm_atomic.LoadUint64(&m.afterInitMessagesChanCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.InitMessagesChan")
	}
}

type mChatServiceMockSendMessage struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockSendMessageExpectation
	expectations       []*ChatServiceMockSendMessageExpectation

	callArgs []*ChatServiceMockSendMessageParams
	mutex    sync.RWMutex
}

// ChatServiceMockSendMessageExpectation specifies expectation struct of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockSendMessageParams
	results *ChatServiceMockSendMessageResults
	Counter uint64
}

// ChatServiceMockSendMessageParams contains parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParams struct {
	ctx    context.Context
	text   string
	chatID int64
}

// ChatServiceMockSendMessageResults contains results of the ChatService.SendMessage
type ChatServiceMockSendMessageResults struct {
	err error
}

// Expect sets up expected params for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Expect(ctx context.Context, text string, chatID int64) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &ChatServiceMockSendMessageParams{ctx, text, chatID}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Inspect(f func(ctx context.Context, text string, chatID int64)) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Return(err error) *ChatServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServiceMockSendMessageResults{err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatService.SendMessage method
func (mmSendMessage *mChatServiceMockSendMessage) Set(f func(ctx context.Context, text string, chatID int64) (err error)) *ChatServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatService.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatService.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the ChatService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServiceMockSendMessage) When(ctx context.Context, text string, chatID int64) *ChatServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServiceMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatServiceMockSendMessageParams{ctx, text, chatID},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatService.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockSendMessageExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockSendMessageResults{err}
	return e.mock
}

// SendMessage implements service.ChatService
func (mmSendMessage *ChatServiceMock) SendMessage(ctx context.Context, text string, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, text, chatID)
	}

	mm_params := ChatServiceMockSendMessageParams{ctx, text, chatID}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_got := ChatServiceMockSendMessageParams{ctx, text, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServiceMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, text, chatID)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServiceMock.SendMessage. %v %v %v", ctx, text, chatID)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServiceMockSendMessage) Calls() []*ChatServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.SendMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckChatAvailabilityInspect()

			m.MinimockCheckCtxUserChatAvailabilityInspect()

			m.MinimockConnectChatInspect()

			m.MinimockCreateChatInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockGetAvailableChatsAndCountInspect()

			m.MinimockGetChannelsInspect()

			m.MinimockGetChatMessagesAndCountInspect()

			m.MinimockInitMessagesChanInspect()

			m.MinimockSendMessageInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckChatAvailabilityDone() &&
		m.MinimockCheckCtxUserChatAvailabilityDone() &&
		m.MinimockConnectChatDone() &&
		m.MinimockCreateChatDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockGetAvailableChatsAndCountDone() &&
		m.MinimockGetChannelsDone() &&
		m.MinimockGetChatMessagesAndCountDone() &&
		m.MinimockInitMessagesChanDone() &&
		m.MinimockSendMessageDone()
}
