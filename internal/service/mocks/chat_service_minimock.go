// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/gomscourse/chat-server/internal/service.ChatService -o chat_service_minimock.go -n ChatServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	serviceModel "github.com/gomscourse/chat-server/internal/model"
)

// ChatServiceMock implements service.ChatService
type ChatServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateChat          func(ctx context.Context, usernames []string) (i1 int64, err error)
	inspectFuncCreateChat   func(ctx context.Context, usernames []string)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatServiceMockCreateChat

	funcDeleteChat          func(ctx context.Context, chatID int64) (err error)
	inspectFuncDeleteChat   func(ctx context.Context, chatID int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatServiceMockDeleteChat

	funcGetChatMessages          func(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, err error)
	inspectFuncGetChatMessages   func(ctx context.Context, chatID int64, page int64, pageSize int64)
	afterGetChatMessagesCounter  uint64
	beforeGetChatMessagesCounter uint64
	GetChatMessagesMock          mChatServiceMockGetChatMessages

	funcGetChatMessagesCount          func(ctx context.Context, chatID int64) (u1 uint64, err error)
	inspectFuncGetChatMessagesCount   func(ctx context.Context, chatID int64)
	afterGetChatMessagesCountCounter  uint64
	beforeGetChatMessagesCountCounter uint64
	GetChatMessagesCountMock          mChatServiceMockGetChatMessagesCount

	funcSendMessage          func(ctx context.Context, sender string, text string, chatID int64) (err error)
	inspectFuncSendMessage   func(ctx context.Context, sender string, text string, chatID int64)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServiceMockSendMessage
}

// NewChatServiceMock returns a mock for service.ChatService
func NewChatServiceMock(t minimock.Tester) *ChatServiceMock {
	m := &ChatServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateChatMock = mChatServiceMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatServiceMockCreateChatParams{}

	m.DeleteChatMock = mChatServiceMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatServiceMockDeleteChatParams{}

	m.GetChatMessagesMock = mChatServiceMockGetChatMessages{mock: m}
	m.GetChatMessagesMock.callArgs = []*ChatServiceMockGetChatMessagesParams{}

	m.GetChatMessagesCountMock = mChatServiceMockGetChatMessagesCount{mock: m}
	m.GetChatMessagesCountMock.callArgs = []*ChatServiceMockGetChatMessagesCountParams{}

	m.SendMessageMock = mChatServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceMockCreateChat struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCreateChatExpectation
	expectations       []*ChatServiceMockCreateChatExpectation

	callArgs []*ChatServiceMockCreateChatParams
	mutex    sync.RWMutex
}

// ChatServiceMockCreateChatExpectation specifies expectation struct of the ChatService.CreateChat
type ChatServiceMockCreateChatExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockCreateChatParams
	results *ChatServiceMockCreateChatResults
	Counter uint64
}

// ChatServiceMockCreateChatParams contains parameters of the ChatService.CreateChat
type ChatServiceMockCreateChatParams struct {
	ctx       context.Context
	usernames []string
}

// ChatServiceMockCreateChatResults contains results of the ChatService.CreateChat
type ChatServiceMockCreateChatResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Expect(ctx context.Context, usernames []string) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{}
	}

	mmCreateChat.defaultExpectation.params = &ChatServiceMockCreateChatParams{ctx, usernames}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Inspect(f func(ctx context.Context, usernames []string)) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Return(i1 int64, err error) *ChatServiceMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatServiceMockCreateChatResults{i1, err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatService.CreateChat method
func (mmCreateChat *mChatServiceMockCreateChat) Set(f func(ctx context.Context, usernames []string) (i1 int64, err error)) *ChatServiceMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatService.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatService.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the ChatService.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatServiceMockCreateChat) When(ctx context.Context, usernames []string) *ChatServiceMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatServiceMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &ChatServiceMockCreateChatParams{ctx, usernames},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCreateChatExpectation) Then(i1 int64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockCreateChatResults{i1, err}
	return e.mock
}

// CreateChat implements service.ChatService
func (mmCreateChat *ChatServiceMock) CreateChat(ctx context.Context, usernames []string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, usernames)
	}

	mm_params := ChatServiceMockCreateChatParams{ctx, usernames}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_got := ChatServiceMockCreateChatParams{ctx, usernames}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatServiceMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, usernames)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatServiceMock.CreateChat. %v %v", ctx, usernames)
	return
}

// CreateChatAfterCounter returns a count of finished ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatServiceMockCreateChat) Calls() []*ChatServiceMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCreateChatDone() bool {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.CreateChat")
	}
}

type mChatServiceMockDeleteChat struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockDeleteChatExpectation
	expectations       []*ChatServiceMockDeleteChatExpectation

	callArgs []*ChatServiceMockDeleteChatParams
	mutex    sync.RWMutex
}

// ChatServiceMockDeleteChatExpectation specifies expectation struct of the ChatService.DeleteChat
type ChatServiceMockDeleteChatExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockDeleteChatParams
	results *ChatServiceMockDeleteChatResults
	Counter uint64
}

// ChatServiceMockDeleteChatParams contains parameters of the ChatService.DeleteChat
type ChatServiceMockDeleteChatParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServiceMockDeleteChatResults contains results of the ChatService.DeleteChat
type ChatServiceMockDeleteChatResults struct {
	err error
}

// Expect sets up expected params for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Expect(ctx context.Context, chatID int64) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	mmDeleteChat.defaultExpectation.params = &ChatServiceMockDeleteChatParams{ctx, chatID}
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Inspect(f func(ctx context.Context, chatID int64)) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Return(err error) *ChatServiceMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatServiceMockDeleteChatResults{err}
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatService.DeleteChat method
func (mmDeleteChat *mChatServiceMockDeleteChat) Set(f func(ctx context.Context, chatID int64) (err error)) *ChatServiceMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatService.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatService.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	return mmDeleteChat.mock
}

// When sets expectation for the ChatService.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServiceMockDeleteChat) When(ctx context.Context, chatID int64) *ChatServiceMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatServiceMockDeleteChatExpectation{
		mock:   mmDeleteChat.mock,
		params: &ChatServiceMockDeleteChatParams{ctx, chatID},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockDeleteChatExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockDeleteChatResults{err}
	return e.mock
}

// DeleteChat implements service.ChatService
func (mmDeleteChat *ChatServiceMock) DeleteChat(ctx context.Context, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, chatID)
	}

	mm_params := ChatServiceMockDeleteChatParams{ctx, chatID}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_got := ChatServiceMockDeleteChatParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatServiceMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, chatID)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatServiceMock.DeleteChat. %v %v", ctx, chatID)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServiceMockDeleteChat) Calls() []*ChatServiceMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockDeleteChatDone() bool {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.DeleteChat")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.DeleteChat")
	}
}

type mChatServiceMockGetChatMessages struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetChatMessagesExpectation
	expectations       []*ChatServiceMockGetChatMessagesExpectation

	callArgs []*ChatServiceMockGetChatMessagesParams
	mutex    sync.RWMutex
}

// ChatServiceMockGetChatMessagesExpectation specifies expectation struct of the ChatService.GetChatMessages
type ChatServiceMockGetChatMessagesExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockGetChatMessagesParams
	results *ChatServiceMockGetChatMessagesResults
	Counter uint64
}

// ChatServiceMockGetChatMessagesParams contains parameters of the ChatService.GetChatMessages
type ChatServiceMockGetChatMessagesParams struct {
	ctx      context.Context
	chatID   int64
	page     int64
	pageSize int64
}

// ChatServiceMockGetChatMessagesResults contains results of the ChatService.GetChatMessages
type ChatServiceMockGetChatMessagesResults struct {
	cpa1 []*serviceModel.ChatMessage
	err  error
}

// Expect sets up expected params for ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Expect(ctx context.Context, chatID int64, page int64, pageSize int64) *mChatServiceMockGetChatMessages {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatServiceMockGetChatMessagesExpectation{}
	}

	mmGetChatMessages.defaultExpectation.params = &ChatServiceMockGetChatMessagesParams{ctx, chatID, page, pageSize}
	for _, e := range mmGetChatMessages.expectations {
		if minimock.Equal(e.params, mmGetChatMessages.defaultExpectation.params) {
			mmGetChatMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatMessages.defaultExpectation.params)
		}
	}

	return mmGetChatMessages
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Inspect(f func(ctx context.Context, chatID int64, page int64, pageSize int64)) *mChatServiceMockGetChatMessages {
	if mmGetChatMessages.mock.inspectFuncGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetChatMessages")
	}

	mmGetChatMessages.mock.inspectFuncGetChatMessages = f

	return mmGetChatMessages
}

// Return sets up results that will be returned by ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Return(cpa1 []*serviceModel.ChatMessage, err error) *ChatServiceMock {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatServiceMockGetChatMessagesExpectation{mock: mmGetChatMessages.mock}
	}
	mmGetChatMessages.defaultExpectation.results = &ChatServiceMockGetChatMessagesResults{cpa1, err}
	return mmGetChatMessages.mock
}

// Set uses given function f to mock the ChatService.GetChatMessages method
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Set(f func(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, err error)) *ChatServiceMock {
	if mmGetChatMessages.defaultExpectation != nil {
		mmGetChatMessages.mock.t.Fatalf("Default expectation is already set for the ChatService.GetChatMessages method")
	}

	if len(mmGetChatMessages.expectations) > 0 {
		mmGetChatMessages.mock.t.Fatalf("Some expectations are already set for the ChatService.GetChatMessages method")
	}

	mmGetChatMessages.mock.funcGetChatMessages = f
	return mmGetChatMessages.mock
}

// When sets expectation for the ChatService.GetChatMessages which will trigger the result defined by the following
// Then helper
func (mmGetChatMessages *mChatServiceMockGetChatMessages) When(ctx context.Context, chatID int64, page int64, pageSize int64) *ChatServiceMockGetChatMessagesExpectation {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	expectation := &ChatServiceMockGetChatMessagesExpectation{
		mock:   mmGetChatMessages.mock,
		params: &ChatServiceMockGetChatMessagesParams{ctx, chatID, page, pageSize},
	}
	mmGetChatMessages.expectations = append(mmGetChatMessages.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetChatMessages return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetChatMessagesExpectation) Then(cpa1 []*serviceModel.ChatMessage, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetChatMessagesResults{cpa1, err}
	return e.mock
}

// GetChatMessages implements service.ChatService
func (mmGetChatMessages *ChatServiceMock) GetChatMessages(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, err error) {
	mm_atomic.AddUint64(&mmGetChatMessages.beforeGetChatMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatMessages.afterGetChatMessagesCounter, 1)

	if mmGetChatMessages.inspectFuncGetChatMessages != nil {
		mmGetChatMessages.inspectFuncGetChatMessages(ctx, chatID, page, pageSize)
	}

	mm_params := ChatServiceMockGetChatMessagesParams{ctx, chatID, page, pageSize}

	// Record call args
	mmGetChatMessages.GetChatMessagesMock.mutex.Lock()
	mmGetChatMessages.GetChatMessagesMock.callArgs = append(mmGetChatMessages.GetChatMessagesMock.callArgs, &mm_params)
	mmGetChatMessages.GetChatMessagesMock.mutex.Unlock()

	for _, e := range mmGetChatMessages.GetChatMessagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetChatMessages.GetChatMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatMessages.GetChatMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatMessages.GetChatMessagesMock.defaultExpectation.params
		mm_got := ChatServiceMockGetChatMessagesParams{ctx, chatID, page, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatMessages.t.Errorf("ChatServiceMock.GetChatMessages got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatMessages.GetChatMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatMessages.t.Fatal("No results are set for the ChatServiceMock.GetChatMessages")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetChatMessages.funcGetChatMessages != nil {
		return mmGetChatMessages.funcGetChatMessages(ctx, chatID, page, pageSize)
	}
	mmGetChatMessages.t.Fatalf("Unexpected call to ChatServiceMock.GetChatMessages. %v %v %v %v", ctx, chatID, page, pageSize)
	return
}

// GetChatMessagesAfterCounter returns a count of finished ChatServiceMock.GetChatMessages invocations
func (mmGetChatMessages *ChatServiceMock) GetChatMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessages.afterGetChatMessagesCounter)
}

// GetChatMessagesBeforeCounter returns a count of ChatServiceMock.GetChatMessages invocations
func (mmGetChatMessages *ChatServiceMock) GetChatMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessages.beforeGetChatMessagesCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetChatMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Calls() []*ChatServiceMockGetChatMessagesParams {
	mmGetChatMessages.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetChatMessagesParams, len(mmGetChatMessages.callArgs))
	copy(argCopy, mmGetChatMessages.callArgs)

	mmGetChatMessages.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatMessagesDone returns true if the count of the GetChatMessages invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetChatMessagesDone() bool {
	for _, e := range m.GetChatMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessages != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetChatMessagesInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetChatMessagesInspect() {
	for _, e := range m.GetChatMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessages with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		if m.GetChatMessagesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.GetChatMessages")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessages with params: %#v", *m.GetChatMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessages != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.GetChatMessages")
	}
}

type mChatServiceMockGetChatMessagesCount struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetChatMessagesCountExpectation
	expectations       []*ChatServiceMockGetChatMessagesCountExpectation

	callArgs []*ChatServiceMockGetChatMessagesCountParams
	mutex    sync.RWMutex
}

// ChatServiceMockGetChatMessagesCountExpectation specifies expectation struct of the ChatService.GetChatMessagesCount
type ChatServiceMockGetChatMessagesCountExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockGetChatMessagesCountParams
	results *ChatServiceMockGetChatMessagesCountResults
	Counter uint64
}

// ChatServiceMockGetChatMessagesCountParams contains parameters of the ChatService.GetChatMessagesCount
type ChatServiceMockGetChatMessagesCountParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServiceMockGetChatMessagesCountResults contains results of the ChatService.GetChatMessagesCount
type ChatServiceMockGetChatMessagesCountResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for ChatService.GetChatMessagesCount
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) Expect(ctx context.Context, chatID int64) *mChatServiceMockGetChatMessagesCount {
	if mmGetChatMessagesCount.mock.funcGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesCount mock is already set by Set")
	}

	if mmGetChatMessagesCount.defaultExpectation == nil {
		mmGetChatMessagesCount.defaultExpectation = &ChatServiceMockGetChatMessagesCountExpectation{}
	}

	mmGetChatMessagesCount.defaultExpectation.params = &ChatServiceMockGetChatMessagesCountParams{ctx, chatID}
	for _, e := range mmGetChatMessagesCount.expectations {
		if minimock.Equal(e.params, mmGetChatMessagesCount.defaultExpectation.params) {
			mmGetChatMessagesCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatMessagesCount.defaultExpectation.params)
		}
	}

	return mmGetChatMessagesCount
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetChatMessagesCount
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) Inspect(f func(ctx context.Context, chatID int64)) *mChatServiceMockGetChatMessagesCount {
	if mmGetChatMessagesCount.mock.inspectFuncGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetChatMessagesCount")
	}

	mmGetChatMessagesCount.mock.inspectFuncGetChatMessagesCount = f

	return mmGetChatMessagesCount
}

// Return sets up results that will be returned by ChatService.GetChatMessagesCount
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) Return(u1 uint64, err error) *ChatServiceMock {
	if mmGetChatMessagesCount.mock.funcGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesCount mock is already set by Set")
	}

	if mmGetChatMessagesCount.defaultExpectation == nil {
		mmGetChatMessagesCount.defaultExpectation = &ChatServiceMockGetChatMessagesCountExpectation{mock: mmGetChatMessagesCount.mock}
	}
	mmGetChatMessagesCount.defaultExpectation.results = &ChatServiceMockGetChatMessagesCountResults{u1, err}
	return mmGetChatMessagesCount.mock
}

// Set uses given function f to mock the ChatService.GetChatMessagesCount method
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) Set(f func(ctx context.Context, chatID int64) (u1 uint64, err error)) *ChatServiceMock {
	if mmGetChatMessagesCount.defaultExpectation != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("Default expectation is already set for the ChatService.GetChatMessagesCount method")
	}

	if len(mmGetChatMessagesCount.expectations) > 0 {
		mmGetChatMessagesCount.mock.t.Fatalf("Some expectations are already set for the ChatService.GetChatMessagesCount method")
	}

	mmGetChatMessagesCount.mock.funcGetChatMessagesCount = f
	return mmGetChatMessagesCount.mock
}

// When sets expectation for the ChatService.GetChatMessagesCount which will trigger the result defined by the following
// Then helper
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) When(ctx context.Context, chatID int64) *ChatServiceMockGetChatMessagesCountExpectation {
	if mmGetChatMessagesCount.mock.funcGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesCount mock is already set by Set")
	}

	expectation := &ChatServiceMockGetChatMessagesCountExpectation{
		mock:   mmGetChatMessagesCount.mock,
		params: &ChatServiceMockGetChatMessagesCountParams{ctx, chatID},
	}
	mmGetChatMessagesCount.expectations = append(mmGetChatMessagesCount.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetChatMessagesCount return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetChatMessagesCountExpectation) Then(u1 uint64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetChatMessagesCountResults{u1, err}
	return e.mock
}

// GetChatMessagesCount implements service.ChatService
func (mmGetChatMessagesCount *ChatServiceMock) GetChatMessagesCount(ctx context.Context, chatID int64) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetChatMessagesCount.beforeGetChatMessagesCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatMessagesCount.afterGetChatMessagesCountCounter, 1)

	if mmGetChatMessagesCount.inspectFuncGetChatMessagesCount != nil {
		mmGetChatMessagesCount.inspectFuncGetChatMessagesCount(ctx, chatID)
	}

	mm_params := ChatServiceMockGetChatMessagesCountParams{ctx, chatID}

	// Record call args
	mmGetChatMessagesCount.GetChatMessagesCountMock.mutex.Lock()
	mmGetChatMessagesCount.GetChatMessagesCountMock.callArgs = append(mmGetChatMessagesCount.GetChatMessagesCountMock.callArgs, &mm_params)
	mmGetChatMessagesCount.GetChatMessagesCountMock.mutex.Unlock()

	for _, e := range mmGetChatMessagesCount.GetChatMessagesCountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation.params
		mm_got := ChatServiceMockGetChatMessagesCountParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatMessagesCount.t.Errorf("ChatServiceMock.GetChatMessagesCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatMessagesCount.t.Fatal("No results are set for the ChatServiceMock.GetChatMessagesCount")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetChatMessagesCount.funcGetChatMessagesCount != nil {
		return mmGetChatMessagesCount.funcGetChatMessagesCount(ctx, chatID)
	}
	mmGetChatMessagesCount.t.Fatalf("Unexpected call to ChatServiceMock.GetChatMessagesCount. %v %v", ctx, chatID)
	return
}

// GetChatMessagesCountAfterCounter returns a count of finished ChatServiceMock.GetChatMessagesCount invocations
func (mmGetChatMessagesCount *ChatServiceMock) GetChatMessagesCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessagesCount.afterGetChatMessagesCountCounter)
}

// GetChatMessagesCountBeforeCounter returns a count of ChatServiceMock.GetChatMessagesCount invocations
func (mmGetChatMessagesCount *ChatServiceMock) GetChatMessagesCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessagesCount.beforeGetChatMessagesCountCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetChatMessagesCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) Calls() []*ChatServiceMockGetChatMessagesCountParams {
	mmGetChatMessagesCount.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetChatMessagesCountParams, len(mmGetChatMessagesCount.callArgs))
	copy(argCopy, mmGetChatMessagesCount.callArgs)

	mmGetChatMessagesCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatMessagesCountDone returns true if the count of the GetChatMessagesCount invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetChatMessagesCountDone() bool {
	for _, e := range m.GetChatMessagesCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessagesCount != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetChatMessagesCountInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetChatMessagesCountInspect() {
	for _, e := range m.GetChatMessagesCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessagesCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		if m.GetChatMessagesCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.GetChatMessagesCount")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessagesCount with params: %#v", *m.GetChatMessagesCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessagesCount != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.GetChatMessagesCount")
	}
}

type mChatServiceMockSendMessage struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockSendMessageExpectation
	expectations       []*ChatServiceMockSendMessageExpectation

	callArgs []*ChatServiceMockSendMessageParams
	mutex    sync.RWMutex
}

// ChatServiceMockSendMessageExpectation specifies expectation struct of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockSendMessageParams
	results *ChatServiceMockSendMessageResults
	Counter uint64
}

// ChatServiceMockSendMessageParams contains parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParams struct {
	ctx    context.Context
	sender string
	text   string
	chatID int64
}

// ChatServiceMockSendMessageResults contains results of the ChatService.SendMessage
type ChatServiceMockSendMessageResults struct {
	err error
}

// Expect sets up expected params for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Expect(ctx context.Context, sender string, text string, chatID int64) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &ChatServiceMockSendMessageParams{ctx, sender, text, chatID}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Inspect(f func(ctx context.Context, sender string, text string, chatID int64)) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Return(err error) *ChatServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServiceMockSendMessageResults{err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatService.SendMessage method
func (mmSendMessage *mChatServiceMockSendMessage) Set(f func(ctx context.Context, sender string, text string, chatID int64) (err error)) *ChatServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatService.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatService.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the ChatService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServiceMockSendMessage) When(ctx context.Context, sender string, text string, chatID int64) *ChatServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServiceMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatServiceMockSendMessageParams{ctx, sender, text, chatID},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatService.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockSendMessageExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockSendMessageResults{err}
	return e.mock
}

// SendMessage implements service.ChatService
func (mmSendMessage *ChatServiceMock) SendMessage(ctx context.Context, sender string, text string, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, sender, text, chatID)
	}

	mm_params := ChatServiceMockSendMessageParams{ctx, sender, text, chatID}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_got := ChatServiceMockSendMessageParams{ctx, sender, text, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServiceMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, sender, text, chatID)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServiceMock.SendMessage. %v %v %v %v", ctx, sender, text, chatID)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServiceMockSendMessage) Calls() []*ChatServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.SendMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateChatInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockGetChatMessagesInspect()

			m.MinimockGetChatMessagesCountInspect()

			m.MinimockSendMessageInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateChatDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockGetChatMessagesDone() &&
		m.MinimockGetChatMessagesCountDone() &&
		m.MinimockSendMessageDone()
}
