// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/gomscourse/chat-server/internal/service.ChatService -o chat_service_minimock.go -n ChatServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	serviceModel "github.com/gomscourse/chat-server/internal/model"
	mm_service "github.com/gomscourse/chat-server/internal/service"
)

// ChatServiceMock implements service.ChatService
type ChatServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConnectChat          func(stream mm_service.Stream, chatID int64) (err error)
	inspectFuncConnectChat   func(stream mm_service.Stream, chatID int64)
	afterConnectChatCounter  uint64
	beforeConnectChatCounter uint64
	ConnectChatMock          mChatServiceMockConnectChat

	funcCreateChat          func(ctx context.Context, usernames []string, title string) (i1 int64, err error)
	inspectFuncCreateChat   func(ctx context.Context, usernames []string, title string)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatServiceMockCreateChat

	funcDeleteChat          func(ctx context.Context, chatID int64) (err error)
	inspectFuncDeleteChat   func(ctx context.Context, chatID int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatServiceMockDeleteChat

	funcGetAvailableChatsAndCount          func(ctx context.Context, page int64, pageSize int64) (cpa1 []*serviceModel.Chat, u1 uint64, err error)
	inspectFuncGetAvailableChatsAndCount   func(ctx context.Context, page int64, pageSize int64)
	afterGetAvailableChatsAndCountCounter  uint64
	beforeGetAvailableChatsAndCountCounter uint64
	GetAvailableChatsAndCountMock          mChatServiceMockGetAvailableChatsAndCount

	funcGetChatMessages          func(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, err error)
	inspectFuncGetChatMessages   func(ctx context.Context, chatID int64, page int64, pageSize int64)
	afterGetChatMessagesCounter  uint64
	beforeGetChatMessagesCounter uint64
	GetChatMessagesMock          mChatServiceMockGetChatMessages

	funcGetChatMessagesAndCount          func(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, u1 uint64, err error)
	inspectFuncGetChatMessagesAndCount   func(ctx context.Context, chatID int64, page int64, pageSize int64)
	afterGetChatMessagesAndCountCounter  uint64
	beforeGetChatMessagesAndCountCounter uint64
	GetChatMessagesAndCountMock          mChatServiceMockGetChatMessagesAndCount

	funcGetChatMessagesCount          func(ctx context.Context, chatID int64) (u1 uint64, err error)
	inspectFuncGetChatMessagesCount   func(ctx context.Context, chatID int64)
	afterGetChatMessagesCountCounter  uint64
	beforeGetChatMessagesCountCounter uint64
	GetChatMessagesCountMock          mChatServiceMockGetChatMessagesCount

	funcInitMessagesChan          func(chatID int64) (ch1 chan *serviceModel.ChatMessage)
	inspectFuncInitMessagesChan   func(chatID int64)
	afterInitMessagesChanCounter  uint64
	beforeInitMessagesChanCounter uint64
	InitMessagesChanMock          mChatServiceMockInitMessagesChan

	funcSendMessage          func(ctx context.Context, text string, chatID int64) (err error)
	inspectFuncSendMessage   func(ctx context.Context, text string, chatID int64)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServiceMockSendMessage
}

// NewChatServiceMock returns a mock for service.ChatService
func NewChatServiceMock(t minimock.Tester) *ChatServiceMock {
	m := &ChatServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConnectChatMock = mChatServiceMockConnectChat{mock: m}
	m.ConnectChatMock.callArgs = []*ChatServiceMockConnectChatParams{}

	m.CreateChatMock = mChatServiceMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatServiceMockCreateChatParams{}

	m.DeleteChatMock = mChatServiceMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatServiceMockDeleteChatParams{}

	m.GetAvailableChatsAndCountMock = mChatServiceMockGetAvailableChatsAndCount{mock: m}
	m.GetAvailableChatsAndCountMock.callArgs = []*ChatServiceMockGetAvailableChatsAndCountParams{}

	m.GetChatMessagesMock = mChatServiceMockGetChatMessages{mock: m}
	m.GetChatMessagesMock.callArgs = []*ChatServiceMockGetChatMessagesParams{}

	m.GetChatMessagesAndCountMock = mChatServiceMockGetChatMessagesAndCount{mock: m}
	m.GetChatMessagesAndCountMock.callArgs = []*ChatServiceMockGetChatMessagesAndCountParams{}

	m.GetChatMessagesCountMock = mChatServiceMockGetChatMessagesCount{mock: m}
	m.GetChatMessagesCountMock.callArgs = []*ChatServiceMockGetChatMessagesCountParams{}

	m.InitMessagesChanMock = mChatServiceMockInitMessagesChan{mock: m}
	m.InitMessagesChanMock.callArgs = []*ChatServiceMockInitMessagesChanParams{}

	m.SendMessageMock = mChatServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceMockConnectChat struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockConnectChatExpectation
	expectations       []*ChatServiceMockConnectChatExpectation

	callArgs []*ChatServiceMockConnectChatParams
	mutex    sync.RWMutex
}

// ChatServiceMockConnectChatExpectation specifies expectation struct of the ChatService.ConnectChat
type ChatServiceMockConnectChatExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockConnectChatParams
	results *ChatServiceMockConnectChatResults
	Counter uint64
}

// ChatServiceMockConnectChatParams contains parameters of the ChatService.ConnectChat
type ChatServiceMockConnectChatParams struct {
	stream mm_service.Stream
	chatID int64
}

// ChatServiceMockConnectChatResults contains results of the ChatService.ConnectChat
type ChatServiceMockConnectChatResults struct {
	err error
}

// Expect sets up expected params for ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Expect(stream mm_service.Stream, chatID int64) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{}
	}

	mmConnectChat.defaultExpectation.params = &ChatServiceMockConnectChatParams{stream, chatID}
	for _, e := range mmConnectChat.expectations {
		if minimock.Equal(e.params, mmConnectChat.defaultExpectation.params) {
			mmConnectChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConnectChat.defaultExpectation.params)
		}
	}

	return mmConnectChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Inspect(f func(stream mm_service.Stream, chatID int64)) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.inspectFuncConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.ConnectChat")
	}

	mmConnectChat.mock.inspectFuncConnectChat = f

	return mmConnectChat
}

// Return sets up results that will be returned by ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Return(err error) *ChatServiceMock {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{mock: mmConnectChat.mock}
	}
	mmConnectChat.defaultExpectation.results = &ChatServiceMockConnectChatResults{err}
	return mmConnectChat.mock
}

// Set uses given function f to mock the ChatService.ConnectChat method
func (mmConnectChat *mChatServiceMockConnectChat) Set(f func(stream mm_service.Stream, chatID int64) (err error)) *ChatServiceMock {
	if mmConnectChat.defaultExpectation != nil {
		mmConnectChat.mock.t.Fatalf("Default expectation is already set for the ChatService.ConnectChat method")
	}

	if len(mmConnectChat.expectations) > 0 {
		mmConnectChat.mock.t.Fatalf("Some expectations are already set for the ChatService.ConnectChat method")
	}

	mmConnectChat.mock.funcConnectChat = f
	return mmConnectChat.mock
}

// When sets expectation for the ChatService.ConnectChat which will trigger the result defined by the following
// Then helper
func (mmConnectChat *mChatServiceMockConnectChat) When(stream mm_service.Stream, chatID int64) *ChatServiceMockConnectChatExpectation {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	expectation := &ChatServiceMockConnectChatExpectation{
		mock:   mmConnectChat.mock,
		params: &ChatServiceMockConnectChatParams{stream, chatID},
	}
	mmConnectChat.expectations = append(mmConnectChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.ConnectChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockConnectChatExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockConnectChatResults{err}
	return e.mock
}

// ConnectChat implements service.ChatService
func (mmConnectChat *ChatServiceMock) ConnectChat(stream mm_service.Stream, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmConnectChat.beforeConnectChatCounter, 1)
	defer mm_atomic.AddUint64(&mmConnectChat.afterConnectChatCounter, 1)

	if mmConnectChat.inspectFuncConnectChat != nil {
		mmConnectChat.inspectFuncConnectChat(stream, chatID)
	}

	mm_params := ChatServiceMockConnectChatParams{stream, chatID}

	// Record call args
	mmConnectChat.ConnectChatMock.mutex.Lock()
	mmConnectChat.ConnectChatMock.callArgs = append(mmConnectChat.ConnectChatMock.callArgs, &mm_params)
	mmConnectChat.ConnectChatMock.mutex.Unlock()

	for _, e := range mmConnectChat.ConnectChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmConnectChat.ConnectChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConnectChat.ConnectChatMock.defaultExpectation.Counter, 1)
		mm_want := mmConnectChat.ConnectChatMock.defaultExpectation.params
		mm_got := ChatServiceMockConnectChatParams{stream, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConnectChat.t.Errorf("ChatServiceMock.ConnectChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConnectChat.ConnectChatMock.defaultExpectation.results
		if mm_results == nil {
			mmConnectChat.t.Fatal("No results are set for the ChatServiceMock.ConnectChat")
		}
		return (*mm_results).err
	}
	if mmConnectChat.funcConnectChat != nil {
		return mmConnectChat.funcConnectChat(stream, chatID)
	}
	mmConnectChat.t.Fatalf("Unexpected call to ChatServiceMock.ConnectChat. %v %v", stream, chatID)
	return
}

// ConnectChatAfterCounter returns a count of finished ChatServiceMock.ConnectChat invocations
func (mmConnectChat *ChatServiceMock) ConnectChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnectChat.afterConnectChatCounter)
}

// ConnectChatBeforeCounter returns a count of ChatServiceMock.ConnectChat invocations
func (mmConnectChat *ChatServiceMock) ConnectChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnectChat.beforeConnectChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.ConnectChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConnectChat *mChatServiceMockConnectChat) Calls() []*ChatServiceMockConnectChatParams {
	mmConnectChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockConnectChatParams, len(mmConnectChat.callArgs))
	copy(argCopy, mmConnectChat.callArgs)

	mmConnectChat.mutex.RUnlock()

	return argCopy
}

// MinimockConnectChatDone returns true if the count of the ConnectChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockConnectChatDone() bool {
	for _, e := range m.ConnectChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnectChat != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockConnectChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockConnectChatInspect() {
	for _, e := range m.ConnectChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.ConnectChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		if m.ConnectChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.ConnectChat")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.ConnectChat with params: %#v", *m.ConnectChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnectChat != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.ConnectChat")
	}
}

type mChatServiceMockCreateChat struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCreateChatExpectation
	expectations       []*ChatServiceMockCreateChatExpectation

	callArgs []*ChatServiceMockCreateChatParams
	mutex    sync.RWMutex
}

// ChatServiceMockCreateChatExpectation specifies expectation struct of the ChatService.CreateChat
type ChatServiceMockCreateChatExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockCreateChatParams
	results *ChatServiceMockCreateChatResults
	Counter uint64
}

// ChatServiceMockCreateChatParams contains parameters of the ChatService.CreateChat
type ChatServiceMockCreateChatParams struct {
	ctx       context.Context
	usernames []string
	title     string
}

// ChatServiceMockCreateChatResults contains results of the ChatService.CreateChat
type ChatServiceMockCreateChatResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Expect(ctx context.Context, usernames []string, title string) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{}
	}

	mmCreateChat.defaultExpectation.params = &ChatServiceMockCreateChatParams{ctx, usernames, title}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Inspect(f func(ctx context.Context, usernames []string, title string)) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Return(i1 int64, err error) *ChatServiceMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatServiceMockCreateChatResults{i1, err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatService.CreateChat method
func (mmCreateChat *mChatServiceMockCreateChat) Set(f func(ctx context.Context, usernames []string, title string) (i1 int64, err error)) *ChatServiceMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatService.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatService.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the ChatService.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatServiceMockCreateChat) When(ctx context.Context, usernames []string, title string) *ChatServiceMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatServiceMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &ChatServiceMockCreateChatParams{ctx, usernames, title},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCreateChatExpectation) Then(i1 int64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockCreateChatResults{i1, err}
	return e.mock
}

// CreateChat implements service.ChatService
func (mmCreateChat *ChatServiceMock) CreateChat(ctx context.Context, usernames []string, title string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, usernames, title)
	}

	mm_params := ChatServiceMockCreateChatParams{ctx, usernames, title}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_got := ChatServiceMockCreateChatParams{ctx, usernames, title}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatServiceMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, usernames, title)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatServiceMock.CreateChat. %v %v %v", ctx, usernames, title)
	return
}

// CreateChatAfterCounter returns a count of finished ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatServiceMockCreateChat) Calls() []*ChatServiceMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCreateChatDone() bool {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.CreateChat")
	}
}

type mChatServiceMockDeleteChat struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockDeleteChatExpectation
	expectations       []*ChatServiceMockDeleteChatExpectation

	callArgs []*ChatServiceMockDeleteChatParams
	mutex    sync.RWMutex
}

// ChatServiceMockDeleteChatExpectation specifies expectation struct of the ChatService.DeleteChat
type ChatServiceMockDeleteChatExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockDeleteChatParams
	results *ChatServiceMockDeleteChatResults
	Counter uint64
}

// ChatServiceMockDeleteChatParams contains parameters of the ChatService.DeleteChat
type ChatServiceMockDeleteChatParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServiceMockDeleteChatResults contains results of the ChatService.DeleteChat
type ChatServiceMockDeleteChatResults struct {
	err error
}

// Expect sets up expected params for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Expect(ctx context.Context, chatID int64) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	mmDeleteChat.defaultExpectation.params = &ChatServiceMockDeleteChatParams{ctx, chatID}
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Inspect(f func(ctx context.Context, chatID int64)) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Return(err error) *ChatServiceMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatServiceMockDeleteChatResults{err}
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatService.DeleteChat method
func (mmDeleteChat *mChatServiceMockDeleteChat) Set(f func(ctx context.Context, chatID int64) (err error)) *ChatServiceMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatService.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatService.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	return mmDeleteChat.mock
}

// When sets expectation for the ChatService.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServiceMockDeleteChat) When(ctx context.Context, chatID int64) *ChatServiceMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatServiceMockDeleteChatExpectation{
		mock:   mmDeleteChat.mock,
		params: &ChatServiceMockDeleteChatParams{ctx, chatID},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockDeleteChatExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockDeleteChatResults{err}
	return e.mock
}

// DeleteChat implements service.ChatService
func (mmDeleteChat *ChatServiceMock) DeleteChat(ctx context.Context, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, chatID)
	}

	mm_params := ChatServiceMockDeleteChatParams{ctx, chatID}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_got := ChatServiceMockDeleteChatParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatServiceMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, chatID)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatServiceMock.DeleteChat. %v %v", ctx, chatID)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServiceMockDeleteChat) Calls() []*ChatServiceMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockDeleteChatDone() bool {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.DeleteChat")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.DeleteChat")
	}
}

type mChatServiceMockGetAvailableChatsAndCount struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetAvailableChatsAndCountExpectation
	expectations       []*ChatServiceMockGetAvailableChatsAndCountExpectation

	callArgs []*ChatServiceMockGetAvailableChatsAndCountParams
	mutex    sync.RWMutex
}

// ChatServiceMockGetAvailableChatsAndCountExpectation specifies expectation struct of the ChatService.GetAvailableChatsAndCount
type ChatServiceMockGetAvailableChatsAndCountExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockGetAvailableChatsAndCountParams
	results *ChatServiceMockGetAvailableChatsAndCountResults
	Counter uint64
}

// ChatServiceMockGetAvailableChatsAndCountParams contains parameters of the ChatService.GetAvailableChatsAndCount
type ChatServiceMockGetAvailableChatsAndCountParams struct {
	ctx      context.Context
	page     int64
	pageSize int64
}

// ChatServiceMockGetAvailableChatsAndCountResults contains results of the ChatService.GetAvailableChatsAndCount
type ChatServiceMockGetAvailableChatsAndCountResults struct {
	cpa1 []*serviceModel.Chat
	u1   uint64
	err  error
}

// Expect sets up expected params for ChatService.GetAvailableChatsAndCount
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) Expect(ctx context.Context, page int64, pageSize int64) *mChatServiceMockGetAvailableChatsAndCount {
	if mmGetAvailableChatsAndCount.mock.funcGetAvailableChatsAndCount != nil {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("ChatServiceMock.GetAvailableChatsAndCount mock is already set by Set")
	}

	if mmGetAvailableChatsAndCount.defaultExpectation == nil {
		mmGetAvailableChatsAndCount.defaultExpectation = &ChatServiceMockGetAvailableChatsAndCountExpectation{}
	}

	mmGetAvailableChatsAndCount.defaultExpectation.params = &ChatServiceMockGetAvailableChatsAndCountParams{ctx, page, pageSize}
	for _, e := range mmGetAvailableChatsAndCount.expectations {
		if minimock.Equal(e.params, mmGetAvailableChatsAndCount.defaultExpectation.params) {
			mmGetAvailableChatsAndCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAvailableChatsAndCount.defaultExpectation.params)
		}
	}

	return mmGetAvailableChatsAndCount
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetAvailableChatsAndCount
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) Inspect(f func(ctx context.Context, page int64, pageSize int64)) *mChatServiceMockGetAvailableChatsAndCount {
	if mmGetAvailableChatsAndCount.mock.inspectFuncGetAvailableChatsAndCount != nil {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetAvailableChatsAndCount")
	}

	mmGetAvailableChatsAndCount.mock.inspectFuncGetAvailableChatsAndCount = f

	return mmGetAvailableChatsAndCount
}

// Return sets up results that will be returned by ChatService.GetAvailableChatsAndCount
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) Return(cpa1 []*serviceModel.Chat, u1 uint64, err error) *ChatServiceMock {
	if mmGetAvailableChatsAndCount.mock.funcGetAvailableChatsAndCount != nil {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("ChatServiceMock.GetAvailableChatsAndCount mock is already set by Set")
	}

	if mmGetAvailableChatsAndCount.defaultExpectation == nil {
		mmGetAvailableChatsAndCount.defaultExpectation = &ChatServiceMockGetAvailableChatsAndCountExpectation{mock: mmGetAvailableChatsAndCount.mock}
	}
	mmGetAvailableChatsAndCount.defaultExpectation.results = &ChatServiceMockGetAvailableChatsAndCountResults{cpa1, u1, err}
	return mmGetAvailableChatsAndCount.mock
}

// Set uses given function f to mock the ChatService.GetAvailableChatsAndCount method
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) Set(f func(ctx context.Context, page int64, pageSize int64) (cpa1 []*serviceModel.Chat, u1 uint64, err error)) *ChatServiceMock {
	if mmGetAvailableChatsAndCount.defaultExpectation != nil {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("Default expectation is already set for the ChatService.GetAvailableChatsAndCount method")
	}

	if len(mmGetAvailableChatsAndCount.expectations) > 0 {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("Some expectations are already set for the ChatService.GetAvailableChatsAndCount method")
	}

	mmGetAvailableChatsAndCount.mock.funcGetAvailableChatsAndCount = f
	return mmGetAvailableChatsAndCount.mock
}

// When sets expectation for the ChatService.GetAvailableChatsAndCount which will trigger the result defined by the following
// Then helper
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) When(ctx context.Context, page int64, pageSize int64) *ChatServiceMockGetAvailableChatsAndCountExpectation {
	if mmGetAvailableChatsAndCount.mock.funcGetAvailableChatsAndCount != nil {
		mmGetAvailableChatsAndCount.mock.t.Fatalf("ChatServiceMock.GetAvailableChatsAndCount mock is already set by Set")
	}

	expectation := &ChatServiceMockGetAvailableChatsAndCountExpectation{
		mock:   mmGetAvailableChatsAndCount.mock,
		params: &ChatServiceMockGetAvailableChatsAndCountParams{ctx, page, pageSize},
	}
	mmGetAvailableChatsAndCount.expectations = append(mmGetAvailableChatsAndCount.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetAvailableChatsAndCount return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetAvailableChatsAndCountExpectation) Then(cpa1 []*serviceModel.Chat, u1 uint64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetAvailableChatsAndCountResults{cpa1, u1, err}
	return e.mock
}

// GetAvailableChatsAndCount implements service.ChatService
func (mmGetAvailableChatsAndCount *ChatServiceMock) GetAvailableChatsAndCount(ctx context.Context, page int64, pageSize int64) (cpa1 []*serviceModel.Chat, u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetAvailableChatsAndCount.beforeGetAvailableChatsAndCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAvailableChatsAndCount.afterGetAvailableChatsAndCountCounter, 1)

	if mmGetAvailableChatsAndCount.inspectFuncGetAvailableChatsAndCount != nil {
		mmGetAvailableChatsAndCount.inspectFuncGetAvailableChatsAndCount(ctx, page, pageSize)
	}

	mm_params := ChatServiceMockGetAvailableChatsAndCountParams{ctx, page, pageSize}

	// Record call args
	mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.mutex.Lock()
	mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.callArgs = append(mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.callArgs, &mm_params)
	mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.mutex.Unlock()

	for _, e := range mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.u1, e.results.err
		}
	}

	if mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.defaultExpectation.params
		mm_got := ChatServiceMockGetAvailableChatsAndCountParams{ctx, page, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAvailableChatsAndCount.t.Errorf("ChatServiceMock.GetAvailableChatsAndCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAvailableChatsAndCount.GetAvailableChatsAndCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAvailableChatsAndCount.t.Fatal("No results are set for the ChatServiceMock.GetAvailableChatsAndCount")
		}
		return (*mm_results).cpa1, (*mm_results).u1, (*mm_results).err
	}
	if mmGetAvailableChatsAndCount.funcGetAvailableChatsAndCount != nil {
		return mmGetAvailableChatsAndCount.funcGetAvailableChatsAndCount(ctx, page, pageSize)
	}
	mmGetAvailableChatsAndCount.t.Fatalf("Unexpected call to ChatServiceMock.GetAvailableChatsAndCount. %v %v %v", ctx, page, pageSize)
	return
}

// GetAvailableChatsAndCountAfterCounter returns a count of finished ChatServiceMock.GetAvailableChatsAndCount invocations
func (mmGetAvailableChatsAndCount *ChatServiceMock) GetAvailableChatsAndCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAvailableChatsAndCount.afterGetAvailableChatsAndCountCounter)
}

// GetAvailableChatsAndCountBeforeCounter returns a count of ChatServiceMock.GetAvailableChatsAndCount invocations
func (mmGetAvailableChatsAndCount *ChatServiceMock) GetAvailableChatsAndCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAvailableChatsAndCount.beforeGetAvailableChatsAndCountCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetAvailableChatsAndCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAvailableChatsAndCount *mChatServiceMockGetAvailableChatsAndCount) Calls() []*ChatServiceMockGetAvailableChatsAndCountParams {
	mmGetAvailableChatsAndCount.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetAvailableChatsAndCountParams, len(mmGetAvailableChatsAndCount.callArgs))
	copy(argCopy, mmGetAvailableChatsAndCount.callArgs)

	mmGetAvailableChatsAndCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetAvailableChatsAndCountDone returns true if the count of the GetAvailableChatsAndCount invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetAvailableChatsAndCountDone() bool {
	for _, e := range m.GetAvailableChatsAndCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAvailableChatsAndCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAvailableChatsAndCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAvailableChatsAndCount != nil && mm_atomic.LoadUint64(&m.afterGetAvailableChatsAndCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAvailableChatsAndCountInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetAvailableChatsAndCountInspect() {
	for _, e := range m.GetAvailableChatsAndCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetAvailableChatsAndCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAvailableChatsAndCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAvailableChatsAndCountCounter) < 1 {
		if m.GetAvailableChatsAndCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.GetAvailableChatsAndCount")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetAvailableChatsAndCount with params: %#v", *m.GetAvailableChatsAndCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAvailableChatsAndCount != nil && mm_atomic.LoadUint64(&m.afterGetAvailableChatsAndCountCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.GetAvailableChatsAndCount")
	}
}

type mChatServiceMockGetChatMessages struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetChatMessagesExpectation
	expectations       []*ChatServiceMockGetChatMessagesExpectation

	callArgs []*ChatServiceMockGetChatMessagesParams
	mutex    sync.RWMutex
}

// ChatServiceMockGetChatMessagesExpectation specifies expectation struct of the ChatService.GetChatMessages
type ChatServiceMockGetChatMessagesExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockGetChatMessagesParams
	results *ChatServiceMockGetChatMessagesResults
	Counter uint64
}

// ChatServiceMockGetChatMessagesParams contains parameters of the ChatService.GetChatMessages
type ChatServiceMockGetChatMessagesParams struct {
	ctx      context.Context
	chatID   int64
	page     int64
	pageSize int64
}

// ChatServiceMockGetChatMessagesResults contains results of the ChatService.GetChatMessages
type ChatServiceMockGetChatMessagesResults struct {
	cpa1 []*serviceModel.ChatMessage
	err  error
}

// Expect sets up expected params for ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Expect(ctx context.Context, chatID int64, page int64, pageSize int64) *mChatServiceMockGetChatMessages {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatServiceMockGetChatMessagesExpectation{}
	}

	mmGetChatMessages.defaultExpectation.params = &ChatServiceMockGetChatMessagesParams{ctx, chatID, page, pageSize}
	for _, e := range mmGetChatMessages.expectations {
		if minimock.Equal(e.params, mmGetChatMessages.defaultExpectation.params) {
			mmGetChatMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatMessages.defaultExpectation.params)
		}
	}

	return mmGetChatMessages
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Inspect(f func(ctx context.Context, chatID int64, page int64, pageSize int64)) *mChatServiceMockGetChatMessages {
	if mmGetChatMessages.mock.inspectFuncGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetChatMessages")
	}

	mmGetChatMessages.mock.inspectFuncGetChatMessages = f

	return mmGetChatMessages
}

// Return sets up results that will be returned by ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Return(cpa1 []*serviceModel.ChatMessage, err error) *ChatServiceMock {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatServiceMockGetChatMessagesExpectation{mock: mmGetChatMessages.mock}
	}
	mmGetChatMessages.defaultExpectation.results = &ChatServiceMockGetChatMessagesResults{cpa1, err}
	return mmGetChatMessages.mock
}

// Set uses given function f to mock the ChatService.GetChatMessages method
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Set(f func(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, err error)) *ChatServiceMock {
	if mmGetChatMessages.defaultExpectation != nil {
		mmGetChatMessages.mock.t.Fatalf("Default expectation is already set for the ChatService.GetChatMessages method")
	}

	if len(mmGetChatMessages.expectations) > 0 {
		mmGetChatMessages.mock.t.Fatalf("Some expectations are already set for the ChatService.GetChatMessages method")
	}

	mmGetChatMessages.mock.funcGetChatMessages = f
	return mmGetChatMessages.mock
}

// When sets expectation for the ChatService.GetChatMessages which will trigger the result defined by the following
// Then helper
func (mmGetChatMessages *mChatServiceMockGetChatMessages) When(ctx context.Context, chatID int64, page int64, pageSize int64) *ChatServiceMockGetChatMessagesExpectation {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	expectation := &ChatServiceMockGetChatMessagesExpectation{
		mock:   mmGetChatMessages.mock,
		params: &ChatServiceMockGetChatMessagesParams{ctx, chatID, page, pageSize},
	}
	mmGetChatMessages.expectations = append(mmGetChatMessages.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetChatMessages return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetChatMessagesExpectation) Then(cpa1 []*serviceModel.ChatMessage, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetChatMessagesResults{cpa1, err}
	return e.mock
}

// GetChatMessages implements service.ChatService
func (mmGetChatMessages *ChatServiceMock) GetChatMessages(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, err error) {
	mm_atomic.AddUint64(&mmGetChatMessages.beforeGetChatMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatMessages.afterGetChatMessagesCounter, 1)

	if mmGetChatMessages.inspectFuncGetChatMessages != nil {
		mmGetChatMessages.inspectFuncGetChatMessages(ctx, chatID, page, pageSize)
	}

	mm_params := ChatServiceMockGetChatMessagesParams{ctx, chatID, page, pageSize}

	// Record call args
	mmGetChatMessages.GetChatMessagesMock.mutex.Lock()
	mmGetChatMessages.GetChatMessagesMock.callArgs = append(mmGetChatMessages.GetChatMessagesMock.callArgs, &mm_params)
	mmGetChatMessages.GetChatMessagesMock.mutex.Unlock()

	for _, e := range mmGetChatMessages.GetChatMessagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetChatMessages.GetChatMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatMessages.GetChatMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatMessages.GetChatMessagesMock.defaultExpectation.params
		mm_got := ChatServiceMockGetChatMessagesParams{ctx, chatID, page, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatMessages.t.Errorf("ChatServiceMock.GetChatMessages got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatMessages.GetChatMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatMessages.t.Fatal("No results are set for the ChatServiceMock.GetChatMessages")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetChatMessages.funcGetChatMessages != nil {
		return mmGetChatMessages.funcGetChatMessages(ctx, chatID, page, pageSize)
	}
	mmGetChatMessages.t.Fatalf("Unexpected call to ChatServiceMock.GetChatMessages. %v %v %v %v", ctx, chatID, page, pageSize)
	return
}

// GetChatMessagesAfterCounter returns a count of finished ChatServiceMock.GetChatMessages invocations
func (mmGetChatMessages *ChatServiceMock) GetChatMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessages.afterGetChatMessagesCounter)
}

// GetChatMessagesBeforeCounter returns a count of ChatServiceMock.GetChatMessages invocations
func (mmGetChatMessages *ChatServiceMock) GetChatMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessages.beforeGetChatMessagesCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetChatMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Calls() []*ChatServiceMockGetChatMessagesParams {
	mmGetChatMessages.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetChatMessagesParams, len(mmGetChatMessages.callArgs))
	copy(argCopy, mmGetChatMessages.callArgs)

	mmGetChatMessages.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatMessagesDone returns true if the count of the GetChatMessages invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetChatMessagesDone() bool {
	for _, e := range m.GetChatMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessages != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetChatMessagesInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetChatMessagesInspect() {
	for _, e := range m.GetChatMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessages with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		if m.GetChatMessagesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.GetChatMessages")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessages with params: %#v", *m.GetChatMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessages != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.GetChatMessages")
	}
}

type mChatServiceMockGetChatMessagesAndCount struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetChatMessagesAndCountExpectation
	expectations       []*ChatServiceMockGetChatMessagesAndCountExpectation

	callArgs []*ChatServiceMockGetChatMessagesAndCountParams
	mutex    sync.RWMutex
}

// ChatServiceMockGetChatMessagesAndCountExpectation specifies expectation struct of the ChatService.GetChatMessagesAndCount
type ChatServiceMockGetChatMessagesAndCountExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockGetChatMessagesAndCountParams
	results *ChatServiceMockGetChatMessagesAndCountResults
	Counter uint64
}

// ChatServiceMockGetChatMessagesAndCountParams contains parameters of the ChatService.GetChatMessagesAndCount
type ChatServiceMockGetChatMessagesAndCountParams struct {
	ctx      context.Context
	chatID   int64
	page     int64
	pageSize int64
}

// ChatServiceMockGetChatMessagesAndCountResults contains results of the ChatService.GetChatMessagesAndCount
type ChatServiceMockGetChatMessagesAndCountResults struct {
	cpa1 []*serviceModel.ChatMessage
	u1   uint64
	err  error
}

// Expect sets up expected params for ChatService.GetChatMessagesAndCount
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) Expect(ctx context.Context, chatID int64, page int64, pageSize int64) *mChatServiceMockGetChatMessagesAndCount {
	if mmGetChatMessagesAndCount.mock.funcGetChatMessagesAndCount != nil {
		mmGetChatMessagesAndCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesAndCount mock is already set by Set")
	}

	if mmGetChatMessagesAndCount.defaultExpectation == nil {
		mmGetChatMessagesAndCount.defaultExpectation = &ChatServiceMockGetChatMessagesAndCountExpectation{}
	}

	mmGetChatMessagesAndCount.defaultExpectation.params = &ChatServiceMockGetChatMessagesAndCountParams{ctx, chatID, page, pageSize}
	for _, e := range mmGetChatMessagesAndCount.expectations {
		if minimock.Equal(e.params, mmGetChatMessagesAndCount.defaultExpectation.params) {
			mmGetChatMessagesAndCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatMessagesAndCount.defaultExpectation.params)
		}
	}

	return mmGetChatMessagesAndCount
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetChatMessagesAndCount
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) Inspect(f func(ctx context.Context, chatID int64, page int64, pageSize int64)) *mChatServiceMockGetChatMessagesAndCount {
	if mmGetChatMessagesAndCount.mock.inspectFuncGetChatMessagesAndCount != nil {
		mmGetChatMessagesAndCount.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetChatMessagesAndCount")
	}

	mmGetChatMessagesAndCount.mock.inspectFuncGetChatMessagesAndCount = f

	return mmGetChatMessagesAndCount
}

// Return sets up results that will be returned by ChatService.GetChatMessagesAndCount
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) Return(cpa1 []*serviceModel.ChatMessage, u1 uint64, err error) *ChatServiceMock {
	if mmGetChatMessagesAndCount.mock.funcGetChatMessagesAndCount != nil {
		mmGetChatMessagesAndCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesAndCount mock is already set by Set")
	}

	if mmGetChatMessagesAndCount.defaultExpectation == nil {
		mmGetChatMessagesAndCount.defaultExpectation = &ChatServiceMockGetChatMessagesAndCountExpectation{mock: mmGetChatMessagesAndCount.mock}
	}
	mmGetChatMessagesAndCount.defaultExpectation.results = &ChatServiceMockGetChatMessagesAndCountResults{cpa1, u1, err}
	return mmGetChatMessagesAndCount.mock
}

// Set uses given function f to mock the ChatService.GetChatMessagesAndCount method
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) Set(f func(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, u1 uint64, err error)) *ChatServiceMock {
	if mmGetChatMessagesAndCount.defaultExpectation != nil {
		mmGetChatMessagesAndCount.mock.t.Fatalf("Default expectation is already set for the ChatService.GetChatMessagesAndCount method")
	}

	if len(mmGetChatMessagesAndCount.expectations) > 0 {
		mmGetChatMessagesAndCount.mock.t.Fatalf("Some expectations are already set for the ChatService.GetChatMessagesAndCount method")
	}

	mmGetChatMessagesAndCount.mock.funcGetChatMessagesAndCount = f
	return mmGetChatMessagesAndCount.mock
}

// When sets expectation for the ChatService.GetChatMessagesAndCount which will trigger the result defined by the following
// Then helper
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) When(ctx context.Context, chatID int64, page int64, pageSize int64) *ChatServiceMockGetChatMessagesAndCountExpectation {
	if mmGetChatMessagesAndCount.mock.funcGetChatMessagesAndCount != nil {
		mmGetChatMessagesAndCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesAndCount mock is already set by Set")
	}

	expectation := &ChatServiceMockGetChatMessagesAndCountExpectation{
		mock:   mmGetChatMessagesAndCount.mock,
		params: &ChatServiceMockGetChatMessagesAndCountParams{ctx, chatID, page, pageSize},
	}
	mmGetChatMessagesAndCount.expectations = append(mmGetChatMessagesAndCount.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetChatMessagesAndCount return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetChatMessagesAndCountExpectation) Then(cpa1 []*serviceModel.ChatMessage, u1 uint64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetChatMessagesAndCountResults{cpa1, u1, err}
	return e.mock
}

// GetChatMessagesAndCount implements service.ChatService
func (mmGetChatMessagesAndCount *ChatServiceMock) GetChatMessagesAndCount(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetChatMessagesAndCount.beforeGetChatMessagesAndCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatMessagesAndCount.afterGetChatMessagesAndCountCounter, 1)

	if mmGetChatMessagesAndCount.inspectFuncGetChatMessagesAndCount != nil {
		mmGetChatMessagesAndCount.inspectFuncGetChatMessagesAndCount(ctx, chatID, page, pageSize)
	}

	mm_params := ChatServiceMockGetChatMessagesAndCountParams{ctx, chatID, page, pageSize}

	// Record call args
	mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.mutex.Lock()
	mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.callArgs = append(mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.callArgs, &mm_params)
	mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.mutex.Unlock()

	for _, e := range mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.u1, e.results.err
		}
	}

	if mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.defaultExpectation.params
		mm_got := ChatServiceMockGetChatMessagesAndCountParams{ctx, chatID, page, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatMessagesAndCount.t.Errorf("ChatServiceMock.GetChatMessagesAndCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatMessagesAndCount.GetChatMessagesAndCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatMessagesAndCount.t.Fatal("No results are set for the ChatServiceMock.GetChatMessagesAndCount")
		}
		return (*mm_results).cpa1, (*mm_results).u1, (*mm_results).err
	}
	if mmGetChatMessagesAndCount.funcGetChatMessagesAndCount != nil {
		return mmGetChatMessagesAndCount.funcGetChatMessagesAndCount(ctx, chatID, page, pageSize)
	}
	mmGetChatMessagesAndCount.t.Fatalf("Unexpected call to ChatServiceMock.GetChatMessagesAndCount. %v %v %v %v", ctx, chatID, page, pageSize)
	return
}

// GetChatMessagesAndCountAfterCounter returns a count of finished ChatServiceMock.GetChatMessagesAndCount invocations
func (mmGetChatMessagesAndCount *ChatServiceMock) GetChatMessagesAndCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessagesAndCount.afterGetChatMessagesAndCountCounter)
}

// GetChatMessagesAndCountBeforeCounter returns a count of ChatServiceMock.GetChatMessagesAndCount invocations
func (mmGetChatMessagesAndCount *ChatServiceMock) GetChatMessagesAndCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessagesAndCount.beforeGetChatMessagesAndCountCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetChatMessagesAndCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatMessagesAndCount *mChatServiceMockGetChatMessagesAndCount) Calls() []*ChatServiceMockGetChatMessagesAndCountParams {
	mmGetChatMessagesAndCount.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetChatMessagesAndCountParams, len(mmGetChatMessagesAndCount.callArgs))
	copy(argCopy, mmGetChatMessagesAndCount.callArgs)

	mmGetChatMessagesAndCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatMessagesAndCountDone returns true if the count of the GetChatMessagesAndCount invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetChatMessagesAndCountDone() bool {
	for _, e := range m.GetChatMessagesAndCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesAndCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesAndCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessagesAndCount != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesAndCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetChatMessagesAndCountInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetChatMessagesAndCountInspect() {
	for _, e := range m.GetChatMessagesAndCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessagesAndCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesAndCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesAndCountCounter) < 1 {
		if m.GetChatMessagesAndCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.GetChatMessagesAndCount")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessagesAndCount with params: %#v", *m.GetChatMessagesAndCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessagesAndCount != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesAndCountCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.GetChatMessagesAndCount")
	}
}

type mChatServiceMockGetChatMessagesCount struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetChatMessagesCountExpectation
	expectations       []*ChatServiceMockGetChatMessagesCountExpectation

	callArgs []*ChatServiceMockGetChatMessagesCountParams
	mutex    sync.RWMutex
}

// ChatServiceMockGetChatMessagesCountExpectation specifies expectation struct of the ChatService.GetChatMessagesCount
type ChatServiceMockGetChatMessagesCountExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockGetChatMessagesCountParams
	results *ChatServiceMockGetChatMessagesCountResults
	Counter uint64
}

// ChatServiceMockGetChatMessagesCountParams contains parameters of the ChatService.GetChatMessagesCount
type ChatServiceMockGetChatMessagesCountParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServiceMockGetChatMessagesCountResults contains results of the ChatService.GetChatMessagesCount
type ChatServiceMockGetChatMessagesCountResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for ChatService.GetChatMessagesCount
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) Expect(ctx context.Context, chatID int64) *mChatServiceMockGetChatMessagesCount {
	if mmGetChatMessagesCount.mock.funcGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesCount mock is already set by Set")
	}

	if mmGetChatMessagesCount.defaultExpectation == nil {
		mmGetChatMessagesCount.defaultExpectation = &ChatServiceMockGetChatMessagesCountExpectation{}
	}

	mmGetChatMessagesCount.defaultExpectation.params = &ChatServiceMockGetChatMessagesCountParams{ctx, chatID}
	for _, e := range mmGetChatMessagesCount.expectations {
		if minimock.Equal(e.params, mmGetChatMessagesCount.defaultExpectation.params) {
			mmGetChatMessagesCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatMessagesCount.defaultExpectation.params)
		}
	}

	return mmGetChatMessagesCount
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetChatMessagesCount
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) Inspect(f func(ctx context.Context, chatID int64)) *mChatServiceMockGetChatMessagesCount {
	if mmGetChatMessagesCount.mock.inspectFuncGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetChatMessagesCount")
	}

	mmGetChatMessagesCount.mock.inspectFuncGetChatMessagesCount = f

	return mmGetChatMessagesCount
}

// Return sets up results that will be returned by ChatService.GetChatMessagesCount
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) Return(u1 uint64, err error) *ChatServiceMock {
	if mmGetChatMessagesCount.mock.funcGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesCount mock is already set by Set")
	}

	if mmGetChatMessagesCount.defaultExpectation == nil {
		mmGetChatMessagesCount.defaultExpectation = &ChatServiceMockGetChatMessagesCountExpectation{mock: mmGetChatMessagesCount.mock}
	}
	mmGetChatMessagesCount.defaultExpectation.results = &ChatServiceMockGetChatMessagesCountResults{u1, err}
	return mmGetChatMessagesCount.mock
}

// Set uses given function f to mock the ChatService.GetChatMessagesCount method
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) Set(f func(ctx context.Context, chatID int64) (u1 uint64, err error)) *ChatServiceMock {
	if mmGetChatMessagesCount.defaultExpectation != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("Default expectation is already set for the ChatService.GetChatMessagesCount method")
	}

	if len(mmGetChatMessagesCount.expectations) > 0 {
		mmGetChatMessagesCount.mock.t.Fatalf("Some expectations are already set for the ChatService.GetChatMessagesCount method")
	}

	mmGetChatMessagesCount.mock.funcGetChatMessagesCount = f
	return mmGetChatMessagesCount.mock
}

// When sets expectation for the ChatService.GetChatMessagesCount which will trigger the result defined by the following
// Then helper
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) When(ctx context.Context, chatID int64) *ChatServiceMockGetChatMessagesCountExpectation {
	if mmGetChatMessagesCount.mock.funcGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("ChatServiceMock.GetChatMessagesCount mock is already set by Set")
	}

	expectation := &ChatServiceMockGetChatMessagesCountExpectation{
		mock:   mmGetChatMessagesCount.mock,
		params: &ChatServiceMockGetChatMessagesCountParams{ctx, chatID},
	}
	mmGetChatMessagesCount.expectations = append(mmGetChatMessagesCount.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetChatMessagesCount return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetChatMessagesCountExpectation) Then(u1 uint64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetChatMessagesCountResults{u1, err}
	return e.mock
}

// GetChatMessagesCount implements service.ChatService
func (mmGetChatMessagesCount *ChatServiceMock) GetChatMessagesCount(ctx context.Context, chatID int64) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetChatMessagesCount.beforeGetChatMessagesCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatMessagesCount.afterGetChatMessagesCountCounter, 1)

	if mmGetChatMessagesCount.inspectFuncGetChatMessagesCount != nil {
		mmGetChatMessagesCount.inspectFuncGetChatMessagesCount(ctx, chatID)
	}

	mm_params := ChatServiceMockGetChatMessagesCountParams{ctx, chatID}

	// Record call args
	mmGetChatMessagesCount.GetChatMessagesCountMock.mutex.Lock()
	mmGetChatMessagesCount.GetChatMessagesCountMock.callArgs = append(mmGetChatMessagesCount.GetChatMessagesCountMock.callArgs, &mm_params)
	mmGetChatMessagesCount.GetChatMessagesCountMock.mutex.Unlock()

	for _, e := range mmGetChatMessagesCount.GetChatMessagesCountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation.params
		mm_got := ChatServiceMockGetChatMessagesCountParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatMessagesCount.t.Errorf("ChatServiceMock.GetChatMessagesCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatMessagesCount.t.Fatal("No results are set for the ChatServiceMock.GetChatMessagesCount")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetChatMessagesCount.funcGetChatMessagesCount != nil {
		return mmGetChatMessagesCount.funcGetChatMessagesCount(ctx, chatID)
	}
	mmGetChatMessagesCount.t.Fatalf("Unexpected call to ChatServiceMock.GetChatMessagesCount. %v %v", ctx, chatID)
	return
}

// GetChatMessagesCountAfterCounter returns a count of finished ChatServiceMock.GetChatMessagesCount invocations
func (mmGetChatMessagesCount *ChatServiceMock) GetChatMessagesCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessagesCount.afterGetChatMessagesCountCounter)
}

// GetChatMessagesCountBeforeCounter returns a count of ChatServiceMock.GetChatMessagesCount invocations
func (mmGetChatMessagesCount *ChatServiceMock) GetChatMessagesCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessagesCount.beforeGetChatMessagesCountCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetChatMessagesCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatMessagesCount *mChatServiceMockGetChatMessagesCount) Calls() []*ChatServiceMockGetChatMessagesCountParams {
	mmGetChatMessagesCount.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetChatMessagesCountParams, len(mmGetChatMessagesCount.callArgs))
	copy(argCopy, mmGetChatMessagesCount.callArgs)

	mmGetChatMessagesCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatMessagesCountDone returns true if the count of the GetChatMessagesCount invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetChatMessagesCountDone() bool {
	for _, e := range m.GetChatMessagesCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessagesCount != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetChatMessagesCountInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetChatMessagesCountInspect() {
	for _, e := range m.GetChatMessagesCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessagesCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		if m.GetChatMessagesCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.GetChatMessagesCount")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessagesCount with params: %#v", *m.GetChatMessagesCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessagesCount != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.GetChatMessagesCount")
	}
}

type mChatServiceMockInitMessagesChan struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockInitMessagesChanExpectation
	expectations       []*ChatServiceMockInitMessagesChanExpectation

	callArgs []*ChatServiceMockInitMessagesChanParams
	mutex    sync.RWMutex
}

// ChatServiceMockInitMessagesChanExpectation specifies expectation struct of the ChatService.InitMessagesChan
type ChatServiceMockInitMessagesChanExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockInitMessagesChanParams
	results *ChatServiceMockInitMessagesChanResults
	Counter uint64
}

// ChatServiceMockInitMessagesChanParams contains parameters of the ChatService.InitMessagesChan
type ChatServiceMockInitMessagesChanParams struct {
	chatID int64
}

// ChatServiceMockInitMessagesChanResults contains results of the ChatService.InitMessagesChan
type ChatServiceMockInitMessagesChanResults struct {
	ch1 chan *serviceModel.ChatMessage
}

// Expect sets up expected params for ChatService.InitMessagesChan
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) Expect(chatID int64) *mChatServiceMockInitMessagesChan {
	if mmInitMessagesChan.mock.funcInitMessagesChan != nil {
		mmInitMessagesChan.mock.t.Fatalf("ChatServiceMock.InitMessagesChan mock is already set by Set")
	}

	if mmInitMessagesChan.defaultExpectation == nil {
		mmInitMessagesChan.defaultExpectation = &ChatServiceMockInitMessagesChanExpectation{}
	}

	mmInitMessagesChan.defaultExpectation.params = &ChatServiceMockInitMessagesChanParams{chatID}
	for _, e := range mmInitMessagesChan.expectations {
		if minimock.Equal(e.params, mmInitMessagesChan.defaultExpectation.params) {
			mmInitMessagesChan.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitMessagesChan.defaultExpectation.params)
		}
	}

	return mmInitMessagesChan
}

// Inspect accepts an inspector function that has same arguments as the ChatService.InitMessagesChan
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) Inspect(f func(chatID int64)) *mChatServiceMockInitMessagesChan {
	if mmInitMessagesChan.mock.inspectFuncInitMessagesChan != nil {
		mmInitMessagesChan.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.InitMessagesChan")
	}

	mmInitMessagesChan.mock.inspectFuncInitMessagesChan = f

	return mmInitMessagesChan
}

// Return sets up results that will be returned by ChatService.InitMessagesChan
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) Return(ch1 chan *serviceModel.ChatMessage) *ChatServiceMock {
	if mmInitMessagesChan.mock.funcInitMessagesChan != nil {
		mmInitMessagesChan.mock.t.Fatalf("ChatServiceMock.InitMessagesChan mock is already set by Set")
	}

	if mmInitMessagesChan.defaultExpectation == nil {
		mmInitMessagesChan.defaultExpectation = &ChatServiceMockInitMessagesChanExpectation{mock: mmInitMessagesChan.mock}
	}
	mmInitMessagesChan.defaultExpectation.results = &ChatServiceMockInitMessagesChanResults{ch1}
	return mmInitMessagesChan.mock
}

// Set uses given function f to mock the ChatService.InitMessagesChan method
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) Set(f func(chatID int64) (ch1 chan *serviceModel.ChatMessage)) *ChatServiceMock {
	if mmInitMessagesChan.defaultExpectation != nil {
		mmInitMessagesChan.mock.t.Fatalf("Default expectation is already set for the ChatService.InitMessagesChan method")
	}

	if len(mmInitMessagesChan.expectations) > 0 {
		mmInitMessagesChan.mock.t.Fatalf("Some expectations are already set for the ChatService.InitMessagesChan method")
	}

	mmInitMessagesChan.mock.funcInitMessagesChan = f
	return mmInitMessagesChan.mock
}

// When sets expectation for the ChatService.InitMessagesChan which will trigger the result defined by the following
// Then helper
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) When(chatID int64) *ChatServiceMockInitMessagesChanExpectation {
	if mmInitMessagesChan.mock.funcInitMessagesChan != nil {
		mmInitMessagesChan.mock.t.Fatalf("ChatServiceMock.InitMessagesChan mock is already set by Set")
	}

	expectation := &ChatServiceMockInitMessagesChanExpectation{
		mock:   mmInitMessagesChan.mock,
		params: &ChatServiceMockInitMessagesChanParams{chatID},
	}
	mmInitMessagesChan.expectations = append(mmInitMessagesChan.expectations, expectation)
	return expectation
}

// Then sets up ChatService.InitMessagesChan return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockInitMessagesChanExpectation) Then(ch1 chan *serviceModel.ChatMessage) *ChatServiceMock {
	e.results = &ChatServiceMockInitMessagesChanResults{ch1}
	return e.mock
}

// InitMessagesChan implements service.ChatService
func (mmInitMessagesChan *ChatServiceMock) InitMessagesChan(chatID int64) (ch1 chan *serviceModel.ChatMessage) {
	mm_atomic.AddUint64(&mmInitMessagesChan.beforeInitMessagesChanCounter, 1)
	defer mm_atomic.AddUint64(&mmInitMessagesChan.afterInitMessagesChanCounter, 1)

	if mmInitMessagesChan.inspectFuncInitMessagesChan != nil {
		mmInitMessagesChan.inspectFuncInitMessagesChan(chatID)
	}

	mm_params := ChatServiceMockInitMessagesChanParams{chatID}

	// Record call args
	mmInitMessagesChan.InitMessagesChanMock.mutex.Lock()
	mmInitMessagesChan.InitMessagesChanMock.callArgs = append(mmInitMessagesChan.InitMessagesChanMock.callArgs, &mm_params)
	mmInitMessagesChan.InitMessagesChanMock.mutex.Unlock()

	for _, e := range mmInitMessagesChan.InitMessagesChanMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ch1
		}
	}

	if mmInitMessagesChan.InitMessagesChanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitMessagesChan.InitMessagesChanMock.defaultExpectation.Counter, 1)
		mm_want := mmInitMessagesChan.InitMessagesChanMock.defaultExpectation.params
		mm_got := ChatServiceMockInitMessagesChanParams{chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitMessagesChan.t.Errorf("ChatServiceMock.InitMessagesChan got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInitMessagesChan.InitMessagesChanMock.defaultExpectation.results
		if mm_results == nil {
			mmInitMessagesChan.t.Fatal("No results are set for the ChatServiceMock.InitMessagesChan")
		}
		return (*mm_results).ch1
	}
	if mmInitMessagesChan.funcInitMessagesChan != nil {
		return mmInitMessagesChan.funcInitMessagesChan(chatID)
	}
	mmInitMessagesChan.t.Fatalf("Unexpected call to ChatServiceMock.InitMessagesChan. %v", chatID)
	return
}

// InitMessagesChanAfterCounter returns a count of finished ChatServiceMock.InitMessagesChan invocations
func (mmInitMessagesChan *ChatServiceMock) InitMessagesChanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitMessagesChan.afterInitMessagesChanCounter)
}

// InitMessagesChanBeforeCounter returns a count of ChatServiceMock.InitMessagesChan invocations
func (mmInitMessagesChan *ChatServiceMock) InitMessagesChanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitMessagesChan.beforeInitMessagesChanCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.InitMessagesChan.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitMessagesChan *mChatServiceMockInitMessagesChan) Calls() []*ChatServiceMockInitMessagesChanParams {
	mmInitMessagesChan.mutex.RLock()

	argCopy := make([]*ChatServiceMockInitMessagesChanParams, len(mmInitMessagesChan.callArgs))
	copy(argCopy, mmInitMessagesChan.callArgs)

	mmInitMessagesChan.mutex.RUnlock()

	return argCopy
}

// MinimockInitMessagesChanDone returns true if the count of the InitMessagesChan invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockInitMessagesChanDone() bool {
	for _, e := range m.InitMessagesChanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMessagesChanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitMessagesChanCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitMessagesChan != nil && mm_atomic.LoadUint64(&m.afterInitMessagesChanCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitMessagesChanInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockInitMessagesChanInspect() {
	for _, e := range m.InitMessagesChanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.InitMessagesChan with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMessagesChanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitMessagesChanCounter) < 1 {
		if m.InitMessagesChanMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.InitMessagesChan")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.InitMessagesChan with params: %#v", *m.InitMessagesChanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitMessagesChan != nil && mm_atomic.LoadUint64(&m.afterInitMessagesChanCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.InitMessagesChan")
	}
}

type mChatServiceMockSendMessage struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockSendMessageExpectation
	expectations       []*ChatServiceMockSendMessageExpectation

	callArgs []*ChatServiceMockSendMessageParams
	mutex    sync.RWMutex
}

// ChatServiceMockSendMessageExpectation specifies expectation struct of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockSendMessageParams
	results *ChatServiceMockSendMessageResults
	Counter uint64
}

// ChatServiceMockSendMessageParams contains parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParams struct {
	ctx    context.Context
	text   string
	chatID int64
}

// ChatServiceMockSendMessageResults contains results of the ChatService.SendMessage
type ChatServiceMockSendMessageResults struct {
	err error
}

// Expect sets up expected params for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Expect(ctx context.Context, text string, chatID int64) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &ChatServiceMockSendMessageParams{ctx, text, chatID}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Inspect(f func(ctx context.Context, text string, chatID int64)) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Return(err error) *ChatServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServiceMockSendMessageResults{err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatService.SendMessage method
func (mmSendMessage *mChatServiceMockSendMessage) Set(f func(ctx context.Context, text string, chatID int64) (err error)) *ChatServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatService.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatService.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the ChatService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServiceMockSendMessage) When(ctx context.Context, text string, chatID int64) *ChatServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServiceMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatServiceMockSendMessageParams{ctx, text, chatID},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatService.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockSendMessageExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockSendMessageResults{err}
	return e.mock
}

// SendMessage implements service.ChatService
func (mmSendMessage *ChatServiceMock) SendMessage(ctx context.Context, text string, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, text, chatID)
	}

	mm_params := ChatServiceMockSendMessageParams{ctx, text, chatID}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_got := ChatServiceMockSendMessageParams{ctx, text, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServiceMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, text, chatID)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServiceMock.SendMessage. %v %v %v", ctx, text, chatID)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServiceMockSendMessage) Calls() []*ChatServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.SendMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConnectChatInspect()

			m.MinimockCreateChatInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockGetAvailableChatsAndCountInspect()

			m.MinimockGetChatMessagesInspect()

			m.MinimockGetChatMessagesAndCountInspect()

			m.MinimockGetChatMessagesCountInspect()

			m.MinimockInitMessagesChanInspect()

			m.MinimockSendMessageInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConnectChatDone() &&
		m.MinimockCreateChatDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockGetAvailableChatsAndCountDone() &&
		m.MinimockGetChatMessagesDone() &&
		m.MinimockGetChatMessagesAndCountDone() &&
		m.MinimockGetChatMessagesCountDone() &&
		m.MinimockInitMessagesChanDone() &&
		m.MinimockSendMessageDone()
}
