// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/gomscourse/chat-server/internal/repository.ChatRepository -o chat_repository_minimock.go -n ChatRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	serviceModel "github.com/gomscourse/chat-server/internal/model"
)

// ChatRepositoryMock implements repository.ChatRepository
type ChatRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddUsersToChat          func(ctx context.Context, chatID int64, usernames []string) (err error)
	inspectFuncAddUsersToChat   func(ctx context.Context, chatID int64, usernames []string)
	afterAddUsersToChatCounter  uint64
	beforeAddUsersToChatCounter uint64
	AddUsersToChatMock          mChatRepositoryMockAddUsersToChat

	funcCreateChat          func(ctx context.Context, title string) (i1 int64, err error)
	inspectFuncCreateChat   func(ctx context.Context, title string)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatRepositoryMockCreateChat

	funcCreateMessage          func(ctx context.Context, chatID int64, sender string, text string) (i1 int64, err error)
	inspectFuncCreateMessage   func(ctx context.Context, chatID int64, sender string, text string)
	afterCreateMessageCounter  uint64
	beforeCreateMessageCounter uint64
	CreateMessageMock          mChatRepositoryMockCreateMessage

	funcDeleteChat          func(ctx context.Context, id int64) (err error)
	inspectFuncDeleteChat   func(ctx context.Context, id int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatRepositoryMockDeleteChat

	funcGetChatMessages          func(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, err error)
	inspectFuncGetChatMessages   func(ctx context.Context, chatID int64, page int64, pageSize int64)
	afterGetChatMessagesCounter  uint64
	beforeGetChatMessagesCounter uint64
	GetChatMessagesMock          mChatRepositoryMockGetChatMessages

	funcGetChatMessagesCount          func(ctx context.Context, chatID int64) (u1 uint64, err error)
	inspectFuncGetChatMessagesCount   func(ctx context.Context, chatID int64)
	afterGetChatMessagesCountCounter  uint64
	beforeGetChatMessagesCountCounter uint64
	GetChatMessagesCountMock          mChatRepositoryMockGetChatMessagesCount
}

// NewChatRepositoryMock returns a mock for repository.ChatRepository
func NewChatRepositoryMock(t minimock.Tester) *ChatRepositoryMock {
	m := &ChatRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddUsersToChatMock = mChatRepositoryMockAddUsersToChat{mock: m}
	m.AddUsersToChatMock.callArgs = []*ChatRepositoryMockAddUsersToChatParams{}

	m.CreateChatMock = mChatRepositoryMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatRepositoryMockCreateChatParams{}

	m.CreateMessageMock = mChatRepositoryMockCreateMessage{mock: m}
	m.CreateMessageMock.callArgs = []*ChatRepositoryMockCreateMessageParams{}

	m.DeleteChatMock = mChatRepositoryMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatRepositoryMockDeleteChatParams{}

	m.GetChatMessagesMock = mChatRepositoryMockGetChatMessages{mock: m}
	m.GetChatMessagesMock.callArgs = []*ChatRepositoryMockGetChatMessagesParams{}

	m.GetChatMessagesCountMock = mChatRepositoryMockGetChatMessagesCount{mock: m}
	m.GetChatMessagesCountMock.callArgs = []*ChatRepositoryMockGetChatMessagesCountParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatRepositoryMockAddUsersToChat struct {
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockAddUsersToChatExpectation
	expectations       []*ChatRepositoryMockAddUsersToChatExpectation

	callArgs []*ChatRepositoryMockAddUsersToChatParams
	mutex    sync.RWMutex
}

// ChatRepositoryMockAddUsersToChatExpectation specifies expectation struct of the ChatRepository.AddUsersToChat
type ChatRepositoryMockAddUsersToChatExpectation struct {
	mock    *ChatRepositoryMock
	params  *ChatRepositoryMockAddUsersToChatParams
	results *ChatRepositoryMockAddUsersToChatResults
	Counter uint64
}

// ChatRepositoryMockAddUsersToChatParams contains parameters of the ChatRepository.AddUsersToChat
type ChatRepositoryMockAddUsersToChatParams struct {
	ctx       context.Context
	chatID    int64
	usernames []string
}

// ChatRepositoryMockAddUsersToChatResults contains results of the ChatRepository.AddUsersToChat
type ChatRepositoryMockAddUsersToChatResults struct {
	err error
}

// Expect sets up expected params for ChatRepository.AddUsersToChat
func (mmAddUsersToChat *mChatRepositoryMockAddUsersToChat) Expect(ctx context.Context, chatID int64, usernames []string) *mChatRepositoryMockAddUsersToChat {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepositoryMockAddUsersToChatExpectation{}
	}

	mmAddUsersToChat.defaultExpectation.params = &ChatRepositoryMockAddUsersToChatParams{ctx, chatID, usernames}
	for _, e := range mmAddUsersToChat.expectations {
		if minimock.Equal(e.params, mmAddUsersToChat.defaultExpectation.params) {
			mmAddUsersToChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUsersToChat.defaultExpectation.params)
		}
	}

	return mmAddUsersToChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.AddUsersToChat
func (mmAddUsersToChat *mChatRepositoryMockAddUsersToChat) Inspect(f func(ctx context.Context, chatID int64, usernames []string)) *mChatRepositoryMockAddUsersToChat {
	if mmAddUsersToChat.mock.inspectFuncAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.AddUsersToChat")
	}

	mmAddUsersToChat.mock.inspectFuncAddUsersToChat = f

	return mmAddUsersToChat
}

// Return sets up results that will be returned by ChatRepository.AddUsersToChat
func (mmAddUsersToChat *mChatRepositoryMockAddUsersToChat) Return(err error) *ChatRepositoryMock {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepositoryMockAddUsersToChatExpectation{mock: mmAddUsersToChat.mock}
	}
	mmAddUsersToChat.defaultExpectation.results = &ChatRepositoryMockAddUsersToChatResults{err}
	return mmAddUsersToChat.mock
}

// Set uses given function f to mock the ChatRepository.AddUsersToChat method
func (mmAddUsersToChat *mChatRepositoryMockAddUsersToChat) Set(f func(ctx context.Context, chatID int64, usernames []string) (err error)) *ChatRepositoryMock {
	if mmAddUsersToChat.defaultExpectation != nil {
		mmAddUsersToChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.AddUsersToChat method")
	}

	if len(mmAddUsersToChat.expectations) > 0 {
		mmAddUsersToChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.AddUsersToChat method")
	}

	mmAddUsersToChat.mock.funcAddUsersToChat = f
	return mmAddUsersToChat.mock
}

// When sets expectation for the ChatRepository.AddUsersToChat which will trigger the result defined by the following
// Then helper
func (mmAddUsersToChat *mChatRepositoryMockAddUsersToChat) When(ctx context.Context, chatID int64, usernames []string) *ChatRepositoryMockAddUsersToChatExpectation {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryMock.AddUsersToChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockAddUsersToChatExpectation{
		mock:   mmAddUsersToChat.mock,
		params: &ChatRepositoryMockAddUsersToChatParams{ctx, chatID, usernames},
	}
	mmAddUsersToChat.expectations = append(mmAddUsersToChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.AddUsersToChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockAddUsersToChatExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockAddUsersToChatResults{err}
	return e.mock
}

// AddUsersToChat implements repository.ChatRepository
func (mmAddUsersToChat *ChatRepositoryMock) AddUsersToChat(ctx context.Context, chatID int64, usernames []string) (err error) {
	mm_atomic.AddUint64(&mmAddUsersToChat.beforeAddUsersToChatCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUsersToChat.afterAddUsersToChatCounter, 1)

	if mmAddUsersToChat.inspectFuncAddUsersToChat != nil {
		mmAddUsersToChat.inspectFuncAddUsersToChat(ctx, chatID, usernames)
	}

	mm_params := ChatRepositoryMockAddUsersToChatParams{ctx, chatID, usernames}

	// Record call args
	mmAddUsersToChat.AddUsersToChatMock.mutex.Lock()
	mmAddUsersToChat.AddUsersToChatMock.callArgs = append(mmAddUsersToChat.AddUsersToChatMock.callArgs, &mm_params)
	mmAddUsersToChat.AddUsersToChatMock.mutex.Unlock()

	for _, e := range mmAddUsersToChat.AddUsersToChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddUsersToChat.AddUsersToChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.params
		mm_got := ChatRepositoryMockAddUsersToChatParams{ctx, chatID, usernames}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUsersToChat.t.Errorf("ChatRepositoryMock.AddUsersToChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.results
		if mm_results == nil {
			mmAddUsersToChat.t.Fatal("No results are set for the ChatRepositoryMock.AddUsersToChat")
		}
		return (*mm_results).err
	}
	if mmAddUsersToChat.funcAddUsersToChat != nil {
		return mmAddUsersToChat.funcAddUsersToChat(ctx, chatID, usernames)
	}
	mmAddUsersToChat.t.Fatalf("Unexpected call to ChatRepositoryMock.AddUsersToChat. %v %v %v", ctx, chatID, usernames)
	return
}

// AddUsersToChatAfterCounter returns a count of finished ChatRepositoryMock.AddUsersToChat invocations
func (mmAddUsersToChat *ChatRepositoryMock) AddUsersToChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUsersToChat.afterAddUsersToChatCounter)
}

// AddUsersToChatBeforeCounter returns a count of ChatRepositoryMock.AddUsersToChat invocations
func (mmAddUsersToChat *ChatRepositoryMock) AddUsersToChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUsersToChat.beforeAddUsersToChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.AddUsersToChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUsersToChat *mChatRepositoryMockAddUsersToChat) Calls() []*ChatRepositoryMockAddUsersToChatParams {
	mmAddUsersToChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockAddUsersToChatParams, len(mmAddUsersToChat.callArgs))
	copy(argCopy, mmAddUsersToChat.callArgs)

	mmAddUsersToChat.mutex.RUnlock()

	return argCopy
}

// MinimockAddUsersToChatDone returns true if the count of the AddUsersToChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockAddUsersToChatDone() bool {
	for _, e := range m.AddUsersToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddUsersToChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddUsersToChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUsersToChat != nil && mm_atomic.LoadUint64(&m.afterAddUsersToChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddUsersToChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockAddUsersToChatInspect() {
	for _, e := range m.AddUsersToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.AddUsersToChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddUsersToChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddUsersToChatCounter) < 1 {
		if m.AddUsersToChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.AddUsersToChat")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.AddUsersToChat with params: %#v", *m.AddUsersToChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUsersToChat != nil && mm_atomic.LoadUint64(&m.afterAddUsersToChatCounter) < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.AddUsersToChat")
	}
}

type mChatRepositoryMockCreateChat struct {
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockCreateChatExpectation
	expectations       []*ChatRepositoryMockCreateChatExpectation

	callArgs []*ChatRepositoryMockCreateChatParams
	mutex    sync.RWMutex
}

// ChatRepositoryMockCreateChatExpectation specifies expectation struct of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatExpectation struct {
	mock    *ChatRepositoryMock
	params  *ChatRepositoryMockCreateChatParams
	results *ChatRepositoryMockCreateChatResults
	Counter uint64
}

// ChatRepositoryMockCreateChatParams contains parameters of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatParams struct {
	ctx   context.Context
	title string
}

// ChatRepositoryMockCreateChatResults contains results of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Expect(ctx context.Context, title string) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	mmCreateChat.defaultExpectation.params = &ChatRepositoryMockCreateChatParams{ctx, title}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Inspect(f func(ctx context.Context, title string)) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Return(i1 int64, err error) *ChatRepositoryMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatRepositoryMockCreateChatResults{i1, err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatRepository.CreateChat method
func (mmCreateChat *mChatRepositoryMockCreateChat) Set(f func(ctx context.Context, title string) (i1 int64, err error)) *ChatRepositoryMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the ChatRepository.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatRepositoryMockCreateChat) When(ctx context.Context, title string) *ChatRepositoryMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &ChatRepositoryMockCreateChatParams{ctx, title},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockCreateChatExpectation) Then(i1 int64, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockCreateChatResults{i1, err}
	return e.mock
}

// CreateChat implements repository.ChatRepository
func (mmCreateChat *ChatRepositoryMock) CreateChat(ctx context.Context, title string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, title)
	}

	mm_params := ChatRepositoryMockCreateChatParams{ctx, title}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_got := ChatRepositoryMockCreateChatParams{ctx, title}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatRepositoryMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, title)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatRepositoryMock.CreateChat. %v %v", ctx, title)
	return
}

// CreateChatAfterCounter returns a count of finished ChatRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatRepositoryMockCreateChat) Calls() []*ChatRepositoryMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockCreateChatDone() bool {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.CreateChat")
	}
}

type mChatRepositoryMockCreateMessage struct {
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockCreateMessageExpectation
	expectations       []*ChatRepositoryMockCreateMessageExpectation

	callArgs []*ChatRepositoryMockCreateMessageParams
	mutex    sync.RWMutex
}

// ChatRepositoryMockCreateMessageExpectation specifies expectation struct of the ChatRepository.CreateMessage
type ChatRepositoryMockCreateMessageExpectation struct {
	mock    *ChatRepositoryMock
	params  *ChatRepositoryMockCreateMessageParams
	results *ChatRepositoryMockCreateMessageResults
	Counter uint64
}

// ChatRepositoryMockCreateMessageParams contains parameters of the ChatRepository.CreateMessage
type ChatRepositoryMockCreateMessageParams struct {
	ctx    context.Context
	chatID int64
	sender string
	text   string
}

// ChatRepositoryMockCreateMessageResults contains results of the ChatRepository.CreateMessage
type ChatRepositoryMockCreateMessageResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for ChatRepository.CreateMessage
func (mmCreateMessage *mChatRepositoryMockCreateMessage) Expect(ctx context.Context, chatID int64, sender string, text string) *mChatRepositoryMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatRepositoryMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatRepositoryMockCreateMessageExpectation{}
	}

	mmCreateMessage.defaultExpectation.params = &ChatRepositoryMockCreateMessageParams{ctx, chatID, sender, text}
	for _, e := range mmCreateMessage.expectations {
		if minimock.Equal(e.params, mmCreateMessage.defaultExpectation.params) {
			mmCreateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateMessage.defaultExpectation.params)
		}
	}

	return mmCreateMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.CreateMessage
func (mmCreateMessage *mChatRepositoryMockCreateMessage) Inspect(f func(ctx context.Context, chatID int64, sender string, text string)) *mChatRepositoryMockCreateMessage {
	if mmCreateMessage.mock.inspectFuncCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.CreateMessage")
	}

	mmCreateMessage.mock.inspectFuncCreateMessage = f

	return mmCreateMessage
}

// Return sets up results that will be returned by ChatRepository.CreateMessage
func (mmCreateMessage *mChatRepositoryMockCreateMessage) Return(i1 int64, err error) *ChatRepositoryMock {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatRepositoryMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatRepositoryMockCreateMessageExpectation{mock: mmCreateMessage.mock}
	}
	mmCreateMessage.defaultExpectation.results = &ChatRepositoryMockCreateMessageResults{i1, err}
	return mmCreateMessage.mock
}

// Set uses given function f to mock the ChatRepository.CreateMessage method
func (mmCreateMessage *mChatRepositoryMockCreateMessage) Set(f func(ctx context.Context, chatID int64, sender string, text string) (i1 int64, err error)) *ChatRepositoryMock {
	if mmCreateMessage.defaultExpectation != nil {
		mmCreateMessage.mock.t.Fatalf("Default expectation is already set for the ChatRepository.CreateMessage method")
	}

	if len(mmCreateMessage.expectations) > 0 {
		mmCreateMessage.mock.t.Fatalf("Some expectations are already set for the ChatRepository.CreateMessage method")
	}

	mmCreateMessage.mock.funcCreateMessage = f
	return mmCreateMessage.mock
}

// When sets expectation for the ChatRepository.CreateMessage which will trigger the result defined by the following
// Then helper
func (mmCreateMessage *mChatRepositoryMockCreateMessage) When(ctx context.Context, chatID int64, sender string, text string) *ChatRepositoryMockCreateMessageExpectation {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatRepositoryMock.CreateMessage mock is already set by Set")
	}

	expectation := &ChatRepositoryMockCreateMessageExpectation{
		mock:   mmCreateMessage.mock,
		params: &ChatRepositoryMockCreateMessageParams{ctx, chatID, sender, text},
	}
	mmCreateMessage.expectations = append(mmCreateMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.CreateMessage return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockCreateMessageExpectation) Then(i1 int64, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockCreateMessageResults{i1, err}
	return e.mock
}

// CreateMessage implements repository.ChatRepository
func (mmCreateMessage *ChatRepositoryMock) CreateMessage(ctx context.Context, chatID int64, sender string, text string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateMessage.beforeCreateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateMessage.afterCreateMessageCounter, 1)

	if mmCreateMessage.inspectFuncCreateMessage != nil {
		mmCreateMessage.inspectFuncCreateMessage(ctx, chatID, sender, text)
	}

	mm_params := ChatRepositoryMockCreateMessageParams{ctx, chatID, sender, text}

	// Record call args
	mmCreateMessage.CreateMessageMock.mutex.Lock()
	mmCreateMessage.CreateMessageMock.callArgs = append(mmCreateMessage.CreateMessageMock.callArgs, &mm_params)
	mmCreateMessage.CreateMessageMock.mutex.Unlock()

	for _, e := range mmCreateMessage.CreateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateMessage.CreateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateMessage.CreateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateMessage.CreateMessageMock.defaultExpectation.params
		mm_got := ChatRepositoryMockCreateMessageParams{ctx, chatID, sender, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateMessage.t.Errorf("ChatRepositoryMock.CreateMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateMessage.CreateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateMessage.t.Fatal("No results are set for the ChatRepositoryMock.CreateMessage")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateMessage.funcCreateMessage != nil {
		return mmCreateMessage.funcCreateMessage(ctx, chatID, sender, text)
	}
	mmCreateMessage.t.Fatalf("Unexpected call to ChatRepositoryMock.CreateMessage. %v %v %v %v", ctx, chatID, sender, text)
	return
}

// CreateMessageAfterCounter returns a count of finished ChatRepositoryMock.CreateMessage invocations
func (mmCreateMessage *ChatRepositoryMock) CreateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.afterCreateMessageCounter)
}

// CreateMessageBeforeCounter returns a count of ChatRepositoryMock.CreateMessage invocations
func (mmCreateMessage *ChatRepositoryMock) CreateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.beforeCreateMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.CreateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateMessage *mChatRepositoryMockCreateMessage) Calls() []*ChatRepositoryMockCreateMessageParams {
	mmCreateMessage.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockCreateMessageParams, len(mmCreateMessage.callArgs))
	copy(argCopy, mmCreateMessage.callArgs)

	mmCreateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockCreateMessageDone returns true if the count of the CreateMessage invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockCreateMessageDone() bool {
	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMessage != nil && mm_atomic.LoadUint64(&m.afterCreateMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateMessageInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockCreateMessageInspect() {
	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateMessageCounter) < 1 {
		if m.CreateMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.CreateMessage")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateMessage with params: %#v", *m.CreateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMessage != nil && mm_atomic.LoadUint64(&m.afterCreateMessageCounter) < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.CreateMessage")
	}
}

type mChatRepositoryMockDeleteChat struct {
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockDeleteChatExpectation
	expectations       []*ChatRepositoryMockDeleteChatExpectation

	callArgs []*ChatRepositoryMockDeleteChatParams
	mutex    sync.RWMutex
}

// ChatRepositoryMockDeleteChatExpectation specifies expectation struct of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatExpectation struct {
	mock    *ChatRepositoryMock
	params  *ChatRepositoryMockDeleteChatParams
	results *ChatRepositoryMockDeleteChatResults
	Counter uint64
}

// ChatRepositoryMockDeleteChatParams contains parameters of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatParams struct {
	ctx context.Context
	id  int64
}

// ChatRepositoryMockDeleteChatResults contains results of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatResults struct {
	err error
}

// Expect sets up expected params for ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Expect(ctx context.Context, id int64) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{}
	}

	mmDeleteChat.defaultExpectation.params = &ChatRepositoryMockDeleteChatParams{ctx, id}
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Inspect(f func(ctx context.Context, id int64)) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Return(err error) *ChatRepositoryMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatRepositoryMockDeleteChatResults{err}
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatRepository.DeleteChat method
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Set(f func(ctx context.Context, id int64) (err error)) *ChatRepositoryMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	return mmDeleteChat.mock
}

// When sets expectation for the ChatRepository.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatRepositoryMockDeleteChat) When(ctx context.Context, id int64) *ChatRepositoryMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockDeleteChatExpectation{
		mock:   mmDeleteChat.mock,
		params: &ChatRepositoryMockDeleteChatParams{ctx, id},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockDeleteChatExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockDeleteChatResults{err}
	return e.mock
}

// DeleteChat implements repository.ChatRepository
func (mmDeleteChat *ChatRepositoryMock) DeleteChat(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, id)
	}

	mm_params := ChatRepositoryMockDeleteChatParams{ctx, id}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_got := ChatRepositoryMockDeleteChatParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatRepositoryMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatRepositoryMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, id)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatRepositoryMock.DeleteChat. %v %v", ctx, id)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatRepositoryMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatRepositoryMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Calls() []*ChatRepositoryMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockDeleteChatDone() bool {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.DeleteChat")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.DeleteChat")
	}
}

type mChatRepositoryMockGetChatMessages struct {
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockGetChatMessagesExpectation
	expectations       []*ChatRepositoryMockGetChatMessagesExpectation

	callArgs []*ChatRepositoryMockGetChatMessagesParams
	mutex    sync.RWMutex
}

// ChatRepositoryMockGetChatMessagesExpectation specifies expectation struct of the ChatRepository.GetChatMessages
type ChatRepositoryMockGetChatMessagesExpectation struct {
	mock    *ChatRepositoryMock
	params  *ChatRepositoryMockGetChatMessagesParams
	results *ChatRepositoryMockGetChatMessagesResults
	Counter uint64
}

// ChatRepositoryMockGetChatMessagesParams contains parameters of the ChatRepository.GetChatMessages
type ChatRepositoryMockGetChatMessagesParams struct {
	ctx      context.Context
	chatID   int64
	page     int64
	pageSize int64
}

// ChatRepositoryMockGetChatMessagesResults contains results of the ChatRepository.GetChatMessages
type ChatRepositoryMockGetChatMessagesResults struct {
	cpa1 []*serviceModel.ChatMessage
	err  error
}

// Expect sets up expected params for ChatRepository.GetChatMessages
func (mmGetChatMessages *mChatRepositoryMockGetChatMessages) Expect(ctx context.Context, chatID int64, page int64, pageSize int64) *mChatRepositoryMockGetChatMessages {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatRepositoryMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatRepositoryMockGetChatMessagesExpectation{}
	}

	mmGetChatMessages.defaultExpectation.params = &ChatRepositoryMockGetChatMessagesParams{ctx, chatID, page, pageSize}
	for _, e := range mmGetChatMessages.expectations {
		if minimock.Equal(e.params, mmGetChatMessages.defaultExpectation.params) {
			mmGetChatMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatMessages.defaultExpectation.params)
		}
	}

	return mmGetChatMessages
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.GetChatMessages
func (mmGetChatMessages *mChatRepositoryMockGetChatMessages) Inspect(f func(ctx context.Context, chatID int64, page int64, pageSize int64)) *mChatRepositoryMockGetChatMessages {
	if mmGetChatMessages.mock.inspectFuncGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.GetChatMessages")
	}

	mmGetChatMessages.mock.inspectFuncGetChatMessages = f

	return mmGetChatMessages
}

// Return sets up results that will be returned by ChatRepository.GetChatMessages
func (mmGetChatMessages *mChatRepositoryMockGetChatMessages) Return(cpa1 []*serviceModel.ChatMessage, err error) *ChatRepositoryMock {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatRepositoryMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatRepositoryMockGetChatMessagesExpectation{mock: mmGetChatMessages.mock}
	}
	mmGetChatMessages.defaultExpectation.results = &ChatRepositoryMockGetChatMessagesResults{cpa1, err}
	return mmGetChatMessages.mock
}

// Set uses given function f to mock the ChatRepository.GetChatMessages method
func (mmGetChatMessages *mChatRepositoryMockGetChatMessages) Set(f func(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, err error)) *ChatRepositoryMock {
	if mmGetChatMessages.defaultExpectation != nil {
		mmGetChatMessages.mock.t.Fatalf("Default expectation is already set for the ChatRepository.GetChatMessages method")
	}

	if len(mmGetChatMessages.expectations) > 0 {
		mmGetChatMessages.mock.t.Fatalf("Some expectations are already set for the ChatRepository.GetChatMessages method")
	}

	mmGetChatMessages.mock.funcGetChatMessages = f
	return mmGetChatMessages.mock
}

// When sets expectation for the ChatRepository.GetChatMessages which will trigger the result defined by the following
// Then helper
func (mmGetChatMessages *mChatRepositoryMockGetChatMessages) When(ctx context.Context, chatID int64, page int64, pageSize int64) *ChatRepositoryMockGetChatMessagesExpectation {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatRepositoryMock.GetChatMessages mock is already set by Set")
	}

	expectation := &ChatRepositoryMockGetChatMessagesExpectation{
		mock:   mmGetChatMessages.mock,
		params: &ChatRepositoryMockGetChatMessagesParams{ctx, chatID, page, pageSize},
	}
	mmGetChatMessages.expectations = append(mmGetChatMessages.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.GetChatMessages return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockGetChatMessagesExpectation) Then(cpa1 []*serviceModel.ChatMessage, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockGetChatMessagesResults{cpa1, err}
	return e.mock
}

// GetChatMessages implements repository.ChatRepository
func (mmGetChatMessages *ChatRepositoryMock) GetChatMessages(ctx context.Context, chatID int64, page int64, pageSize int64) (cpa1 []*serviceModel.ChatMessage, err error) {
	mm_atomic.AddUint64(&mmGetChatMessages.beforeGetChatMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatMessages.afterGetChatMessagesCounter, 1)

	if mmGetChatMessages.inspectFuncGetChatMessages != nil {
		mmGetChatMessages.inspectFuncGetChatMessages(ctx, chatID, page, pageSize)
	}

	mm_params := ChatRepositoryMockGetChatMessagesParams{ctx, chatID, page, pageSize}

	// Record call args
	mmGetChatMessages.GetChatMessagesMock.mutex.Lock()
	mmGetChatMessages.GetChatMessagesMock.callArgs = append(mmGetChatMessages.GetChatMessagesMock.callArgs, &mm_params)
	mmGetChatMessages.GetChatMessagesMock.mutex.Unlock()

	for _, e := range mmGetChatMessages.GetChatMessagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetChatMessages.GetChatMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatMessages.GetChatMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatMessages.GetChatMessagesMock.defaultExpectation.params
		mm_got := ChatRepositoryMockGetChatMessagesParams{ctx, chatID, page, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatMessages.t.Errorf("ChatRepositoryMock.GetChatMessages got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatMessages.GetChatMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatMessages.t.Fatal("No results are set for the ChatRepositoryMock.GetChatMessages")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetChatMessages.funcGetChatMessages != nil {
		return mmGetChatMessages.funcGetChatMessages(ctx, chatID, page, pageSize)
	}
	mmGetChatMessages.t.Fatalf("Unexpected call to ChatRepositoryMock.GetChatMessages. %v %v %v %v", ctx, chatID, page, pageSize)
	return
}

// GetChatMessagesAfterCounter returns a count of finished ChatRepositoryMock.GetChatMessages invocations
func (mmGetChatMessages *ChatRepositoryMock) GetChatMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessages.afterGetChatMessagesCounter)
}

// GetChatMessagesBeforeCounter returns a count of ChatRepositoryMock.GetChatMessages invocations
func (mmGetChatMessages *ChatRepositoryMock) GetChatMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessages.beforeGetChatMessagesCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.GetChatMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatMessages *mChatRepositoryMockGetChatMessages) Calls() []*ChatRepositoryMockGetChatMessagesParams {
	mmGetChatMessages.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockGetChatMessagesParams, len(mmGetChatMessages.callArgs))
	copy(argCopy, mmGetChatMessages.callArgs)

	mmGetChatMessages.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatMessagesDone returns true if the count of the GetChatMessages invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockGetChatMessagesDone() bool {
	for _, e := range m.GetChatMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessages != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetChatMessagesInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockGetChatMessagesInspect() {
	for _, e := range m.GetChatMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.GetChatMessages with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		if m.GetChatMessagesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.GetChatMessages")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.GetChatMessages with params: %#v", *m.GetChatMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessages != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter) < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.GetChatMessages")
	}
}

type mChatRepositoryMockGetChatMessagesCount struct {
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockGetChatMessagesCountExpectation
	expectations       []*ChatRepositoryMockGetChatMessagesCountExpectation

	callArgs []*ChatRepositoryMockGetChatMessagesCountParams
	mutex    sync.RWMutex
}

// ChatRepositoryMockGetChatMessagesCountExpectation specifies expectation struct of the ChatRepository.GetChatMessagesCount
type ChatRepositoryMockGetChatMessagesCountExpectation struct {
	mock    *ChatRepositoryMock
	params  *ChatRepositoryMockGetChatMessagesCountParams
	results *ChatRepositoryMockGetChatMessagesCountResults
	Counter uint64
}

// ChatRepositoryMockGetChatMessagesCountParams contains parameters of the ChatRepository.GetChatMessagesCount
type ChatRepositoryMockGetChatMessagesCountParams struct {
	ctx    context.Context
	chatID int64
}

// ChatRepositoryMockGetChatMessagesCountResults contains results of the ChatRepository.GetChatMessagesCount
type ChatRepositoryMockGetChatMessagesCountResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for ChatRepository.GetChatMessagesCount
func (mmGetChatMessagesCount *mChatRepositoryMockGetChatMessagesCount) Expect(ctx context.Context, chatID int64) *mChatRepositoryMockGetChatMessagesCount {
	if mmGetChatMessagesCount.mock.funcGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("ChatRepositoryMock.GetChatMessagesCount mock is already set by Set")
	}

	if mmGetChatMessagesCount.defaultExpectation == nil {
		mmGetChatMessagesCount.defaultExpectation = &ChatRepositoryMockGetChatMessagesCountExpectation{}
	}

	mmGetChatMessagesCount.defaultExpectation.params = &ChatRepositoryMockGetChatMessagesCountParams{ctx, chatID}
	for _, e := range mmGetChatMessagesCount.expectations {
		if minimock.Equal(e.params, mmGetChatMessagesCount.defaultExpectation.params) {
			mmGetChatMessagesCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatMessagesCount.defaultExpectation.params)
		}
	}

	return mmGetChatMessagesCount
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.GetChatMessagesCount
func (mmGetChatMessagesCount *mChatRepositoryMockGetChatMessagesCount) Inspect(f func(ctx context.Context, chatID int64)) *mChatRepositoryMockGetChatMessagesCount {
	if mmGetChatMessagesCount.mock.inspectFuncGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.GetChatMessagesCount")
	}

	mmGetChatMessagesCount.mock.inspectFuncGetChatMessagesCount = f

	return mmGetChatMessagesCount
}

// Return sets up results that will be returned by ChatRepository.GetChatMessagesCount
func (mmGetChatMessagesCount *mChatRepositoryMockGetChatMessagesCount) Return(u1 uint64, err error) *ChatRepositoryMock {
	if mmGetChatMessagesCount.mock.funcGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("ChatRepositoryMock.GetChatMessagesCount mock is already set by Set")
	}

	if mmGetChatMessagesCount.defaultExpectation == nil {
		mmGetChatMessagesCount.defaultExpectation = &ChatRepositoryMockGetChatMessagesCountExpectation{mock: mmGetChatMessagesCount.mock}
	}
	mmGetChatMessagesCount.defaultExpectation.results = &ChatRepositoryMockGetChatMessagesCountResults{u1, err}
	return mmGetChatMessagesCount.mock
}

// Set uses given function f to mock the ChatRepository.GetChatMessagesCount method
func (mmGetChatMessagesCount *mChatRepositoryMockGetChatMessagesCount) Set(f func(ctx context.Context, chatID int64) (u1 uint64, err error)) *ChatRepositoryMock {
	if mmGetChatMessagesCount.defaultExpectation != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("Default expectation is already set for the ChatRepository.GetChatMessagesCount method")
	}

	if len(mmGetChatMessagesCount.expectations) > 0 {
		mmGetChatMessagesCount.mock.t.Fatalf("Some expectations are already set for the ChatRepository.GetChatMessagesCount method")
	}

	mmGetChatMessagesCount.mock.funcGetChatMessagesCount = f
	return mmGetChatMessagesCount.mock
}

// When sets expectation for the ChatRepository.GetChatMessagesCount which will trigger the result defined by the following
// Then helper
func (mmGetChatMessagesCount *mChatRepositoryMockGetChatMessagesCount) When(ctx context.Context, chatID int64) *ChatRepositoryMockGetChatMessagesCountExpectation {
	if mmGetChatMessagesCount.mock.funcGetChatMessagesCount != nil {
		mmGetChatMessagesCount.mock.t.Fatalf("ChatRepositoryMock.GetChatMessagesCount mock is already set by Set")
	}

	expectation := &ChatRepositoryMockGetChatMessagesCountExpectation{
		mock:   mmGetChatMessagesCount.mock,
		params: &ChatRepositoryMockGetChatMessagesCountParams{ctx, chatID},
	}
	mmGetChatMessagesCount.expectations = append(mmGetChatMessagesCount.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.GetChatMessagesCount return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockGetChatMessagesCountExpectation) Then(u1 uint64, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockGetChatMessagesCountResults{u1, err}
	return e.mock
}

// GetChatMessagesCount implements repository.ChatRepository
func (mmGetChatMessagesCount *ChatRepositoryMock) GetChatMessagesCount(ctx context.Context, chatID int64) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetChatMessagesCount.beforeGetChatMessagesCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatMessagesCount.afterGetChatMessagesCountCounter, 1)

	if mmGetChatMessagesCount.inspectFuncGetChatMessagesCount != nil {
		mmGetChatMessagesCount.inspectFuncGetChatMessagesCount(ctx, chatID)
	}

	mm_params := ChatRepositoryMockGetChatMessagesCountParams{ctx, chatID}

	// Record call args
	mmGetChatMessagesCount.GetChatMessagesCountMock.mutex.Lock()
	mmGetChatMessagesCount.GetChatMessagesCountMock.callArgs = append(mmGetChatMessagesCount.GetChatMessagesCountMock.callArgs, &mm_params)
	mmGetChatMessagesCount.GetChatMessagesCountMock.mutex.Unlock()

	for _, e := range mmGetChatMessagesCount.GetChatMessagesCountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation.params
		mm_got := ChatRepositoryMockGetChatMessagesCountParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatMessagesCount.t.Errorf("ChatRepositoryMock.GetChatMessagesCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatMessagesCount.GetChatMessagesCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatMessagesCount.t.Fatal("No results are set for the ChatRepositoryMock.GetChatMessagesCount")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetChatMessagesCount.funcGetChatMessagesCount != nil {
		return mmGetChatMessagesCount.funcGetChatMessagesCount(ctx, chatID)
	}
	mmGetChatMessagesCount.t.Fatalf("Unexpected call to ChatRepositoryMock.GetChatMessagesCount. %v %v", ctx, chatID)
	return
}

// GetChatMessagesCountAfterCounter returns a count of finished ChatRepositoryMock.GetChatMessagesCount invocations
func (mmGetChatMessagesCount *ChatRepositoryMock) GetChatMessagesCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessagesCount.afterGetChatMessagesCountCounter)
}

// GetChatMessagesCountBeforeCounter returns a count of ChatRepositoryMock.GetChatMessagesCount invocations
func (mmGetChatMessagesCount *ChatRepositoryMock) GetChatMessagesCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessagesCount.beforeGetChatMessagesCountCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.GetChatMessagesCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatMessagesCount *mChatRepositoryMockGetChatMessagesCount) Calls() []*ChatRepositoryMockGetChatMessagesCountParams {
	mmGetChatMessagesCount.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockGetChatMessagesCountParams, len(mmGetChatMessagesCount.callArgs))
	copy(argCopy, mmGetChatMessagesCount.callArgs)

	mmGetChatMessagesCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatMessagesCountDone returns true if the count of the GetChatMessagesCount invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockGetChatMessagesCountDone() bool {
	for _, e := range m.GetChatMessagesCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessagesCount != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetChatMessagesCountInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockGetChatMessagesCountInspect() {
	for _, e := range m.GetChatMessagesCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.GetChatMessagesCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		if m.GetChatMessagesCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.GetChatMessagesCount")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.GetChatMessagesCount with params: %#v", *m.GetChatMessagesCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessagesCount != nil && mm_atomic.LoadUint64(&m.afterGetChatMessagesCountCounter) < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.GetChatMessagesCount")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddUsersToChatInspect()

			m.MinimockCreateChatInspect()

			m.MinimockCreateMessageInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockGetChatMessagesInspect()

			m.MinimockGetChatMessagesCountInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddUsersToChatDone() &&
		m.MinimockCreateChatDone() &&
		m.MinimockCreateMessageDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockGetChatMessagesDone() &&
		m.MinimockGetChatMessagesCountDone()
}
